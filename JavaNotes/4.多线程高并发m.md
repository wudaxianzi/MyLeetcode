## 一、进程与线程

- 进程：一个程序就是一个进程；进程是资源（内存、CPU、硬盘）分配的基本单位，由操作系统完成分配；

- 线程：是真正执行任务的，一个进程中至少包含一个线程；线程是任务调度的基本单位；线程在执行任务的过程中会共用进程资源。

  **为了提高系统的执行效率，减少处理机的空转时间和调度切换的时间，以及便于系统管理，所以有了线程，线程取代了进程调度的基本功能**

  ![img](D:\算法Typora\picture\008i3skNgy1gtt09patgtj60qq09cq3v02.jpg)

- 并发：请求同时发生（同一时间间隔内）；

- 并行和串行：并行表示同时进行处理任务（多核CPU，同一时刻）；串行是任务一个接一个处理；

- 同步和异步：同步指的是一个任务的开始必须等上一个任务的结束（接力赛）；异步指的是一个任务的开始无需等待其他任务；

- **队列分为串行和并行**

  **任务的执行分为同步和异步**

- **队列只是负责任务的调度，⽽不负责任务的执行**

  **任务是在线程中执行的**

  队列和任务的特点：

  队列的特点：先进先出，排在前面的任务最先执行；


- 串行队列：任务按照顺序被调度，前⼀个任务不执行完毕，队列不会调度

- 并行队列：只要有空闲的线程，队列就会调度当前任务，交给线程去执行，不需要考虑前⾯是都有任务在执行，只要有线程可以利用，队列就会调度任务。

- **同步执行：**不会开启新的线程，任务按顺序执行

  **异步执行：**会开启新的线程，任务可以并发的执行

多线程是为了最大化利用CPU

**线程的状态：**

**NEW  -  RUNNABLE  -  BLOCKED  -  WAITING  -  TIMED_WAITING  -  TERMINATED;**

```java
    public enum State {
        /**
         * Thread state for a thread which has not yet started.
         */
        NEW,

        /**
         * Thread state for a runnable thread.  A thread in the runnable
         * state is executing in the Java virtual machine but it may
         * be waiting for other resources from the operating system
         * such as processor.
         */
        RUNNABLE,

        /**
         * Thread state for a thread blocked waiting for a monitor lock.
         * A thread in the blocked state is waiting for a monitor lock
         * to enter a synchronized block/method or
         * reenter a synchronized block/method after calling
         * {@link Object#wait() Object.wait}.
         */
        BLOCKED,

        /**
         * Thread state for a waiting thread.
         * A thread is in the waiting state due to calling one of the
         * following methods:
         * <ul>
         *   <li>{@link Object#wait() Object.wait} with no timeout</li>
         *   <li>{@link #join() Thread.join} with no timeout</li>
         *   <li>{@link LockSupport#park() LockSupport.park}</li>
         * </ul>
         *
         * <p>A thread in the waiting state is waiting for another thread to
         * perform a particular action.
         *
         * For example, a thread that has called {@code Object.wait()}
         * on an object is waiting for another thread to call
         * {@code Object.notify()} or {@code Object.notifyAll()} on
         * that object. A thread that has called {@code Thread.join()}
         * is waiting for a specified thread to terminate.
         */
        WAITING,

        /**
         * Thread state for a waiting thread with a specified waiting time.
         * A thread is in the timed waiting state due to calling one of
         * the following methods with a specified positive waiting time:
         * <ul>
         *   <li>{@link #sleep Thread.sleep}</li>
         *   <li>{@link Object#wait(long) Object.wait} with timeout</li>
         *   <li>{@link #join(long) Thread.join} with timeout</li>
         *   <li>{@link LockSupport#parkNanos LockSupport.parkNanos}</li>
         *   <li>{@link LockSupport#parkUntil LockSupport.parkUntil}</li>
         * </ul>
         */
        TIMED_WAITING,//限时等待

        /**
         * Thread state for a terminated thread.
         * The thread has completed execution.
         */
        TERMINATED;
    }
```



## 二、线程的创建

**创建线程方式1：自定义一个类区继承Thread 重写run方法**

此方式基本不用，extend只能继承一个，所以**一般能用实现接口的方法就不用继承！**

```java
//先创建一个公共线程类
package Thread;

import java.util.ArrayList;
/*
	方式1：自定义一个类区继承Thread 重写run方法
*/

public class CustomThread extends Thread{
    @Override
    public void run() {
        for (int i = 0; i < 20; i++) {//快捷for：20.for
            System.out.println("执行任务" + i);
        }
    }
}
```

``` java
package Thread;

public class ThreadTest {
    public static void main(String[] args) {
        System.out.println("main start");
        //1、先创建线程对象
        CustomThread customThread = new CustomThread();
        //2、调用start()方法告诉操作系统线程准备好了，可以进行调度
        customThread.start();//虽然启动了 但没有立马进行调用
        System.out.println("main end");
        /*
        输出：
        main start
        main end
        执行任务0
        执行任务1
        ……
         */
        // 因为主线程与创建的线程是同时进行的，所以main end并不是在customThread.start()之后才运行
    }
}

```



**创建线程方式2：实现Runnable接口**：（适用于对**线程无返回值**要求的场景）

1. 使用匿名内部类实现；**注意：匿名内部类中可以是接口，也可以是一个抽象类；**
2. 使用lambda表达式实现。**注意：lambda表达式:只能是接口，且接口中只有一个抽象方法，才可以使用。**

```java
    public static void main(String[] args) {
        //匿名内部类形式
        Thread threadA = new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i < 100; i++) {
                    System.out.println("threadA" + i);
                }
            }
        });
        //lambda表达式形式
        Thread threadB = new Thread(() ->{
            for (int i = 0; i < 100; i++) {
                System.out.println("threadB" + i);
            }
        });
        threadA.start();
        threadB.start();
        // 两个线程的调度是由操作系统完成的，每次运行的结果都会不一样
    }
```

**创建线程方式3：借助中间类FutureTask实现Callable接口**（线程执行完**有返回值**）

1. 使用匿名内部类实现；
2. 使用lambda表达式实现；
3. futureTask.get()获取线程的返回结果。

```java
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        FutureTask<Integer> futureTask = new FutureTask<>(new Callable<Integer>() {//匿名内部类
            @Override
            public Integer call() throws Exception {
                int sum = 0;
                for (int i = 0; i < 20; i++) {
                    sum += i;
                }
                return sum;
            }
        });
        Thread thread = new Thread(futureTask);
        thread.start();
        Integer integer = futureTask.get();//get是一个阻塞式方法，需要等线程执行完成，才会有返回值，所以调用get之前，一定要启动线程。
        System.out.println(integer);
    }
```

**创建线程方式4：使用线程池进行创建**

```java
```





## 三、线程的常用方法

1. threadA.getState()：获取线程的状态；
2. threadA.getId()、getName()：获取OS随机分配的线程ID和名字；
3. threadA.getPriority():获取线程的优先级；
4. Thread.sleep(2000L)：让当前线程休眠，单位是毫秒；但此方法在休眠时间长时不适用；
5. TimeUnit.SECONDS.sleep(10)：此时的时间单位可以自己设定，更方便使用；
6. Thread.currentThread()：获取当前线程；
7. Thread.activeCount()：统计当前激活的线程；注意后台一直有一个gc线程；
8. threadA.join():main线程必须等待threadA执行完了才执行；

```java
public static void main(String[] args) {
    Thread threadA = new Thread(new Runnable() {
        @Override
        public void run() {
            for (int i = 0; i < 20; i++) {
                //System.out.println("执行任务" + i);
            }
            try {
                TimeUnit.SECONDS.sleep(10);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            /*try {
                Thread.sleep(2000L);//写在线程A里面的，所以是让线程A休眠
            } catch (InterruptedException e) {
                e.printStackTrace();
            }*/
            System.out.println("threadA end");
        }
    },"ThreadA");//可以自己指定线程名字
    threadA.start();
    //threadA.getState()：获取线程的状态
    System.out.println(threadA.getState());//RUNNABLE
    //threadA.getId()、getName()：获取OS随机分配的线程ID和名字
    System.out.println("id-" + threadA.getId());//id-15
    System.out.println("name-" + threadA.getName());//name-Thread-0

    //getPriority()线程优先级
    //10表示最大优先级，一般线程优先级都是5；但设定优先级并不代表OS一定优先执行，只是OS先执行的可能性更大
    System.out.println("Priority-" + threadA.getPriority());

    //Thread.sleep(2000L)让当前线程睡眠/ms
    try {
        Thread.sleep(2000L);//这里是让主线程休眠
    } catch (InterruptedException e) {
        e.printStackTrace();
    }

    //获取当前线程
    Thread thread = Thread.currentThread();
    System.out.println("main end");
}
```

```java
    public static void main(String[] args) {
        Thread thread = new Thread(() -> {
            for (int i = 0; i < 20; i++) {
                System.out.println(Thread.currentThread().getName() + "执行任务" + i);
            }
        },"ThreadA");
        thread.start();
        try {
            thread.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.activeCount());//count:2,不止有main线程，还有gc线程
    }
```





## 四、线程安全（synchronized-reentrantLock）

- JMM (Java memory model) Java内存模型。JMM是—套规则规范
- JMM规范中指定Java的每个线程都有自己的工作空间(工作内存)，线程的工作内存是互不干扰的，是相互独立的;线程内部的方法中出现的局部变量都在工作内存中;但线程都可以访问共享主存(共享内存——堆空间和方法区）的空间;
- 当多个线程同时访问共享内存的数据时才会涉及到数据安全问题;

### **1、多线程不安全例子：**

```java
package Thread;
//新建一个银行类
public class BankAccount {
    private  double balance;

    public double getBalance() {
        return balance;
    }

    public synchronized void saveMoney(double money){
        //1，先取出balance的值（从主存中取出到线程的工作内存中）
        //2，累加
        //3，给balance重新赋值
        
        //要保证线程安全，这三步必须保证原子性！只需要加入关键字：synchronized
        
        balance += money;
    }

    public synchronized void withdrawMoney(double money){
        balance -= money;
    }

}

```

```java
package Thread;

public class ThreadSecurity {
    public static void main(String[] args) {
        BankAccount bankAccount = new BankAccount();
        Thread threadA = new Thread(() ->{
            for (int i = 0; i < 20000; i++) {
                bankAccount.saveMoney(100);
            }
            System.out.println("ThreadA end");
        });
        
        Thread threadB = new Thread(() ->{
            for (int i = 0; i < 20000; i++) {
                bankAccount.withdrawMoney(100);
            }
            System.out.println("ThreadB end");
        });

        threadA.start();
        threadB.start();
        System.out.println("余额：" + bankAccount.getBalance());//由于主线程和线程A、线程B并不能同时结束，所以打印结果可能不是零，这就是多线程导致的问题。
    }
}
```

**原子性：多个操作要么同时成功，要么同时失败，方法在执行过程中不被打断！**

### 2、关键字：synchronized

📕（`synchronized`经过javac编译后会生成`monitorenter`和`monitorexit`两个字节码指令->而monitor是依赖操作系统的mutex lock来实现的，所以每当挂起和唤醒一个线程都要切换内核态，因此会影响性能，所以1.6之后引入了**偏向锁和轻量级锁**）

- synchronized是一种**互斥锁**，一次只能允许一个线程进入被锁住的代码块
- synchronized是Java的一个关键字，它能够将**代码块/方法**锁起来
- 如果synchronized修饰的是实例方法，对应的锁则是对象实例
- 如果synchronized修饰的是静态方法，对应的锁则是当前类的Class实例
- 如果synchronized修饰的是代码块，对应的锁则是传入synchronized的对象实例

![img](D:\算法Typora\picture\008i3skNgy1gtt0naqy9fj61ge0bsgo802.jpg)

🐧关于synchronized锁在JDK 1.6之后做的优化：

- 在JDK 1.6之前是重量级锁：加锁是依赖底层操作系统的`mutex`相关指令实现，所以会有**用户态和内核态之间的切换**，性能损耗十分明显
- 而JDK1.6 以后**引入偏向锁和轻量级**锁**在JVM层面实现加锁的逻辑，不依赖底层操作系统**，就没有切换的消耗；

Mark Word对锁的状态记录一共有4种：无锁、偏向锁、轻量级锁（自旋）和重量级锁：

![img](D:\算法Typora\picture\008i3skNgy1gtt0qwr7gyj61bs064q4b02.jpg)

PS：自旋≈CPU空转，->改进后出现了“适应性自旋”，自旋时间不固定；

**1、关键字：synchronized：加在方法声明处，表示当前线程想要去执行这个方法，必须先获得当前对象的对象锁**->线程同步

堆中存放的对象除了有对象的成员变量以外，**每个对象都有一个对象锁，且仅有一个；**

当方法加入synchronized关键字后，当前线程想要执行对象的方法，需先获得对象锁！

所以上述例子在加入synchronized关键字后，不会出现线程不安全问题，因为线程A调用bankAccount对象的saveMoney方法的时候，先获取了bankAccount对象的对象锁，所以线程B想要调用withdrawMoney方法时无法获得bankAccount对象锁！

**2、关键字：synchronized也可以加在方法体内部，表示同步代码块范围缩小了**

```java
package Thread;
//新建一个银行类
public class BankAccount2 {
    private  double balance;
    
public double getBalance() {
    return balance;
}

public void saveMoney(double money){

    synchronized（this）{//这样锁的范围可以更具体！
        balance += money;
    }
    
}

public synchronized void withdrawMoney(double money){
    balance -= money;
	}
}
```

**3、synchronized注意点：**

- synchronized称为内置锁（随着jdk出生的）、可重入锁（无需重复获取锁）、排他锁（互斥锁）、非公平锁

```java
package Thread;
//新建一个银行类
public class BankAccount3 {
    private  double balance;
    
public double getBalance() {
    return balance;
}

public synchronized void saveMoney(double money){

    balance += money;
    withdrawMoney(money);//此处调用的第二个方法也带锁，但无需重复获取对象锁！->可重入锁
}

public synchronized void withdrawMoney(double money){
    balance -= money;
	}
}
```

- synchronized如果用在静态方法上面，表示需要获取类对象的对象锁；

  获取类对象有三种方式

```java
public synchronized static void method3(){

}
```

- synchronized同步方法（同步代码块）在进行执行的过程中，如果有异常产生，可以正常释放对象锁；

- sleep()方法不会释放锁，线程会抱着锁睡；

- 如果一个类内部没有考虑同步，外部使用的时候也可以加同步做到数据安全！

  如果一个类内部使用了方法同步，外部在使用时不需要考虑方法同步，可以放心使用。

  ```java
          Thread threadA = new Thread(() ->{
              synchronized(bankAccount){
                  for (int i = 0; i < 20000; i++) {
                  	bankAccount.saveMoney(100);
              	}	
              }
              System.out.println("ThreadA end");
          });
  ```

### 3、显示锁ReentrantLock（是一个类，纯java写的，借助AQS）：详细的笔记在AQS中

- **ReentrantLock reentrantLock = new ReentrantLock();**
- **上锁和释放锁由程序员控制；**
- **出现异常后显示锁是不会自动释放的，释放锁的代码可以放在finally中，以此避免问题；**
- **显示锁：可重入锁、互斥锁**
- **ReentrantLock默认是把非公平锁；ReentrantLock reentrantLock = new ReentrantLock(true),可传参定义是否为公平锁（先到先得）;性能而言：非公平锁更高**

```java
public class BankAccount {
    private  double balance;
    ReentrantLock reentrantLock = new ReentrantLock();
    public double getBalance() {
        return balance;
    }

    public void saveMoney(double money){
        reentrantLock.lock();//获取锁，阻塞式方法
        balance += money;
        reentrantLock.unlock();
    }

    public void withdrawMoney(double money){
        reentrantLock.lock();//注意要保证锁的唯一性
        balance -= money;
        reentrantLock.unlock();
    }
}
```

- 以下操作是为了避免出现异常时锁没有释放：

```java
public void saveMoney(double money){
    reentrantLock.lock();
    try{
        System.out.println(1 / 0);
        balance += money;
    }finally {
        reentrantLock.unlock();
    }

}
```

### 4、死锁

造成死锁的原因可以简单概括为：当前线程拥有其他线程需要的资源，当前线程等待其他线程已拥有的资源，都不放弃自己拥有的资源。

- 线程之间出现**相互等待**，等待对方释放锁（比如嵌套使用synchronized关键字容易导致死锁）

**解决死锁思路：**

1. 固定加锁的顺序，比如我们可以使用Hash值的大小来确定加锁的先后
2. 尽可能缩减加锁的范围，等到操作共享变量的时候才加锁。
3. 使用可释放的定时锁-tryLock（一段时间申请不到锁的权限了，直接释放掉）

解决1：**reentrantLock.tryLock()**

- 无参模式：boolean reentrantLock.tryLock() 表示尝试获取锁，立刻返回，如果获取到锁，返回true -> 避免阻塞发生死锁

```java
public boolean tryLock() {
    return sync.tryLock();
}
```

- 带参模式：reentrantLock.tryLock(5L, TimeUnit.SECONDS)，等待timeout时间，拿不到锁再放弃；

```java
public boolean tryLock(long timeout, TimeUnit unit)
        throws InterruptedException {
    return sync.tryLockNanos(unit.toNanos(timeout));
}
```

### 5、Synchronized🔒的优化：偏向锁、轻量级锁、重量级锁

铺垫知识📕：

<img src="D:\算法Typora\picture\9f6f835a847e40d9983365329470c640.png" alt="img" style="zoom: 25%;" />

- HotSpot虚拟机中，对象在内存中存储的布局可以分为三块区域：对象头Header、实例数据Instance Data 和对齐填充Padding;
- 对象头包括三部分信息：MarkWord、指向类指针、数组长度

**MarkWord**：比如 hash码，对象所属的年代，对象锁，锁状态标志，偏向锁（线程）ID，偏向时间，数组长度（数组对象）等

![image-20220717102149641](D:\算法Typora\picture\image-20220717102149641.png)



![image-20220716153306210](D:\算法Typora\picture\image-20220716153306210.png)

**在锁标志位：0 0->轻量级锁（自旋锁）、1 0->重量级锁、1 1->锁被回收、0 1->需要再加一个偏向锁位：001->无锁|101->偏向锁**

🧠：马桶竞争例子！

- **偏向锁**（**只有一个线程进入临界区**）：JVM会认为**只有某个线程才会执行同步代码**（没有竞争的环境）🐎：因为经统计，多数的synchronized方法，再很多情况下，只有一个线程在运行（例如StringBuffer中的append、Vector中的一些sync方法等）。

  偏向锁步骤如下：

  - MarkWord会直接记录线程ID，只要线程来执行代码了，会比对线程ID是否相等，相等则当前线程能直接获取得到锁，执行同步代码；
  - 如果不相等，则用CAS来尝试修改当前的线程ID，如果CAS修改成功，那还是能获取得到锁，执行同步代码；
  - 如果CAS失败了，说明有竞争环境，此时会对偏向锁撤销，升级为轻量级锁。

- 轻量级锁（**多个线程交替进入临界区**）：**不经过底层操作系统**，自旋（while)，在轻量级锁的状态下，当前线程会在栈帧下创建`LockRecord`，LockRecord会把Mark Word的信息拷贝进去，且有个**`Owner`指针**指向加锁的对象！线程执行到同步代码块时，则用CAS试图将Mark Word指向线程栈帧的Lock Record，假设**CAS修改成功，则获得轻量级锁**！若修改失败，则自旋，**自旋一定次数后，则升级为重量级锁。**

- 重量级锁（多线程**同时进**入临界区）

🧠**总结**：

- synchronized锁在1.5之前是重量级锁，依赖底层操作系统的mutex指令实现，需要用户态与内核态切换，性能损耗十分明显；
- **重量级锁用到monitor对象，而偏向锁则在Mark Word记录线程ID进行比对，轻量级锁则是拷贝Mark Word到Lock Record中，用CAS＋自旋的方式获取**
- ![img](D:\算法Typora\picture\008i3skNgy1gtt125cqodj61p00c8wh502.jpg)
- 

📕面试题：

1. 为什么有自旋锁还需要重量级锁？
   - **自旋是消耗CPU资源的**，如果锁的时间长，获知自旋线程多，CPU会被大量消耗；
   - **重量级锁有等待队列**，所有拿不到锁的线程进入等待队列，不需要消耗CPU资源。
2. 偏向锁是否一定比自旋锁效率高？
   - 在明确知道会有多线程竞争的情况下，偏向锁会频繁涉及锁撤销，这时候直接使用自旋锁；
   - JVM在启动过程中，会有很多线程竞争，如果使用偏向锁，就会造成偏向锁不断地进行锁撤销和锁升级，效率较低，所以默认情况启动时需要等待4s才能打开偏向锁。`BiasedLockingStartUpDelay=0`->直接启动偏向锁，则new出来的对象，默认就是一个**可偏向匿名对象**`101`。

### 6、公平锁与非公平锁

- 公平锁：在竞争环境下，先到临界区的线程比后到的线程一定更快地获取得到锁；
- 非公平锁：先到临界区的线程未必比后到的线程更快地获取得到锁；如`synchronized`锁就是非公平的

1. 公平锁的实现：

   公平锁可以把竞争的线程放在一个**先进先出的队列**上，只要持有锁的线程执行完了，唤醒队列的下一个线程去获取锁就好了；

2. 非公平锁的实现：

   线程先尝试能不能获取得到锁，如果获取得到锁了就执行同步代码了，如果获取不到锁，那就再把这个线程放到队列；


![img](D:\算法Typora\picture\008i3skNgy1gtt55obq5tj60t409a0to02.jpg)









## 五、线程安全的类

### 1、集合中线程安全的类：

**所谓线程安全就是多个线程去执行某类，这个类始终能表现出正确的行为，那么这个类就是线程安全的。**

🐖：**成员变量**实在共享空间中，多线程是要考虑线程安全问题；而**局部变量**是在线程自己的工作内存中，不需要考虑安全问题！

1、集合中ArrayList不是线程安全的类（但也可以进行外部加锁的方式进行同步）；**Vector**是线程安全的类

```java
package Thread;

import java.util.ArrayList;
import java.util.TreeSet;

public class ThreadSecurityClassTest {
    public static void main(String[] args) {
        //ArrayList<Integer> arrayList = new ArrayList<>(); 不安全
        Vector<Integer> arrayList = new Vector<>();//安全
        Thread threadA = new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i < 1000; i++) {
                    arrayList.add(i);
                }
            }
        },"ThreadA");

        Thread threadB = new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i < 2000; i++) {
                    arrayList.add(i);
                }
            }
        },"ThreadB");

        threadA.start();
        threadB.start();

        try {
            threadA.join();
            threadB.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(arrayList.size());
        System.out.println("结束");
    }
}
/*
Exception in thread "ThreadA" java.lang.ArrayIndexOutOfBoundsException: Index 16 out of bounds for length 15
	at java.base/java.util.ArrayList.add(ArrayList.java:455)
	at java.base/java.util.ArrayList.add(ArrayList.java:467)
	at Thread.ThreadSecurityClassTest$1.run(ThreadSecurityClassTest.java:14)
	at java.base/java.lang.Thread.run(Thread.java:833)
2009
结束

Process finished with exit code 0
*/
```

2、HashMap不是线程安全的；**HashTable**是线程安全的(给每个方法都加了同步，效率低，已被抛弃)，多线程高并发项目建议使用**ConcurrentHashMap**

3、**ConcurrentHashMap**的使用

🐖：ConcurrentHashMapsynchronized关键字是放在方法体内部（同步代码块），且没有锁整个哈希表，且get方法没有加锁（只取数据不会有数据安全问题）

ConcurrentHashMap - put方法源码

```java
public V put(K key, V value) {
    return putVal(key, value, false);
}
```

**synchronized (f)** :只锁桶位(f),这里的桶位指map底层存放在Node数组中的元素，即扩充链表的第一个位置！

<img src="D:\算法Typora\picture\image-20220713170212148.png" alt="image-20220713170212148" style="zoom:50%;" />

**HashMap：**

​	**HashMap**整体上可以看作是**数组+链表**的形式。数组是为了进行快速检索，而如果**hash函数冲突了的话，就会在同一个位置处后面进行挂链表的操作**。也就是说，同一个链表上的节点，它们的hash值计算出来都是一样的。但是如果hash冲突比较多的时候，生成的链表也会拉得比较长，这个时候检索起来就会退化成遍历操作，性能就比较低了。在Java 8中为了改善这种情况，引入了**红黑树**。

​	红黑树是一种高级的平衡二叉树结构，其能**保证查找、插入、删除的时间复杂度最坏为O(logn)**。在大数据量的场景下，相比于AVL树，红黑树的插入删除性能要更高。当链表中的节点数量大于等于8的时候，**同时当前数组中的长度大于等于MIN_TREEIFY_CAPACITY（64）时**，链表中的所有节点会被转化成红黑树，而如果当前链表节点的数量小于等于6的时候，红黑树又会被退化成链表。

​	也就是说**当前数组中的长度（也就是桶bin的个数）必须大于等于64的时候，同时当前这个链表的长度大于等于8的时候，才能转化。**如果当前数组中的长度小于64，即使当前链表的长度已经大于8了，也不会转化。

​	**那么为什么不直接用红黑树来代替链表，而是采用链表和红黑树来搭配在一起使用呢？**原因就在于红黑树虽然性能更好，但是这也仅是在**大数据量**下才能看到差异。如果当前数据量很小，就几个节点的话，那么此时显然用链表的方式会更划算。因为要知道**红黑树的插入和删除操作会涉及到大量的自旋**，以此来保证树结构的平衡。如果数据量小的话，插入删除的性能高效根本抵消不了自旋操作所带来的成本。

​	**还有一点需要留意的是链表转为红黑树的阈值是8，而红黑树退化成链表的阈值是6。**为什么这两个值会不一样呢？将两个阈值错开一些，以此来尽量避免在阈值点附近可能存在的、频繁地做转换数据结构操作而导致性能变低的情况出现。这里之所以阈值会选择为8是通过数学统计上的结论得出的，在源码中也有相关注释。

HashMap底层数据结构示意图：

<img src="D:\算法Typora\picture\image-20220713192505446.png" alt="image-20220713192505446" style="zoom:50%;" />

```java
final V putVal(K key, V value, boolean onlyIfAbsent) {
    if (key == null || value == null) throw new NullPointerException();
    int hash = spread(key.hashCode());
    int binCount = 0;
    for (Node<K,V>[] tab = table;;) {
        Node<K,V> f; int n, i, fh; K fk; V fv;
        if (tab == null || (n = tab.length) == 0)
            tab = initTable();
        else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {
            if (casTabAt(tab, i, null, new Node<K,V>(hash, key, value)))
                break;                   // no lock when adding to empty bin
        }
        else if ((fh = f.hash) == MOVED)
            tab = helpTransfer(tab, f);
        else if (onlyIfAbsent // check first node without acquiring lock
                 && fh == hash
                 && ((fk = f.key) == key || (fk != null && key.equals(fk)))
                 && (fv = f.val) != null)
            return fv;
        else {
            V oldVal = null;
            synchronized (f) {
                if (tabAt(tab, i) == f) {
                    if (fh >= 0) {
                        binCount = 1;
                        for (Node<K,V> e = f;; ++binCount) {
                            K ek;
                            if (e.hash == hash &&
                                ((ek = e.key) == key ||
                                 (ek != null && key.equals(ek)))) {
                                oldVal = e.val;
                                if (!onlyIfAbsent)
                                    e.val = value;
                                break;
                            }
                            Node<K,V> pred = e;
                            if ((e = e.next) == null) {
                                pred.next = new Node<K,V>(hash, key, value);
                                break;
                            }
                        }
                    }
                    else if (f instanceof TreeBin) {
                        Node<K,V> p;
                        binCount = 2;
                        if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key,
                                                       value)) != null) {
                            oldVal = p.val;
                            if (!onlyIfAbsent)
                                p.val = value;
                        }
                    }
                    else if (f instanceof ReservationNode)
                        throw new IllegalStateException("Recursive update");
                }
            }
            if (binCount != 0) {
                if (binCount >= TREEIFY_THRESHOLD)
                    treeifyBin(tab, i);
                if (oldVal != null)
                    return oldVal;
                break;
            }
        }
    }
    addCount(1L, binCount);
    return null;
}
```

ctrl + alt + M：选中代码,快速封装在一个方法中

### 2、原子性类（Atomic）：原理是利用无锁编程CAS(compare and swap)

![image-20220717104910607](D:\算法Typora\picture\image-20220717104910607.png)

​	线程操作完从共享主存中拷贝的值后，新的值想要刷新回主存，需要先**比较**，即比较主存中的值与线程一开始拷贝的值是否一样，一样则说明没有其它线程干扰，可放心地把值同步刷新回主存。

​	**缺点：1、虽然省去了上锁放锁，但源码中依旧有do-while循环** -> 在线程少（竞争少的时候可以使用）

​		 **2、原子性范围有限，只能做到一个共享变量的原子性；**	

2.1 AtomicInteger：

atomicInteger.get() -> 获取值

atomicInteger.incrementAndGet() -> 自加;    decrementAndGet() -> 自减

```java
private static AtomicInteger atomicInteger = new AtomicInteger(0);
public static void main(String[] args){

    Thread threadA = new Thread(new Runnable() {
        @Override
        public void run() {
            for (int i = 0; i < 20; i++) {
                atomicInteger.incrementAndGet();
            }
        }
    },"ThreadA");

    Thread threadB = new Thread(new Runnable() {
        @Override
        public void run() {
            for (int i = 0; i < 20; i++) {
                atomicInteger.incrementAndGet();
            }
        }
    },"ThreadB");
    threadA.start();
    threadB.start();
    try {
        threadA.join();
        threadB.join();
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    System.out.println(atomicInteger.get());

}
```

### 3、CAS的缺点：

📕：

- CAS会带来**ABA的问题**：假设线程A读到当前值是10，可能线程B把值修改为100，然后线程C又把值修改为10；等到线程A拿到执行权时，因为当前值和内存值是一致的，线程A是可以修改的！站在线程A的角度来说，这个值是从未被修改的；这是不合理的，因为我们从上帝的角度来看，这个变量已经被线程B和线程C修改过了。比如涉及到链表节点增删的时候：

  ![img](D:\算法Typora\picture\008i3skNgy1gtt0jzngenj60qo0uc77s02.jpg)

  要解决ABA问题，Java也提供了AtomicStampedReference类供我们用，说白了就是加了个版本，**比对的就是内存值+版本是否一致**；

  📕：不同架构的CPU都提供了指令级别的CAS原子操作，比如X86系统中，通过`cmpxchg`指令支持CAS，使得CPU原生支持CAS，不需要经过mutex等操作；                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                

## 六、线程间的通信

### 6.1 生产者消费者模式 使用场景：线程处理任务速度不匹配

#### 6.1.1 使用synchronized实现

​	**wait()方法**(Object类中的方法) **notify()** **notifyAll()**

- 当需要让当前线程等待（进入对象的等待池）时，调用wait()；
- wait调用完后，当前线程释放对象锁，且当前线程进入当前对象的等待池，只能被其他线程唤醒；
- 线程进入等待池，是为了被唤醒再次重新获取对象锁；
- wait()方法只能在同步方法或者同步代码块中，且一般要用在while循环中
- 唤醒线程:**notify()：随机唤醒一个唤醒当前对象等待池中的线程**；**notifyAll()：唤醒当前对象所有线程**，也只能在同步方法或者同步代码块中

```java
package Thread.communication;

public class Store {
    private int count;
    private final int MAX = 100;//仓库最大容量 -> 可使用内存

    /*
    put:生产商品
     */
    public void put() {
        synchronized (this) {
            while (count == MAX) {
                System.out.println("仓库满了，生产者等待");
                //需要让当前线程等待，并且释放对象锁
                try {
                    this.wait();//wait调用完后，当前线程释放对象锁，且当前线程进入当前对象的等待池
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            count++;
            System.out.println("生产了一件商品");

            //唤醒消费者
            this.notifyAll();
        }
    }
    /*
    get:消费商品
     */
    public void get() {
        synchronized (this) {
            while (count == 0) {
                System.out.println("仓库空了，消费者等待");
                try {
                    this.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
        count--;
        System.out.println("消费了一件商品");
        //随机唤醒某个唤醒当前对象等待池中的线程
        //this.notify();

        //唤醒所有
        this.notifyAll();

    }

}
```

生产者消费者测试：

```java
package Thread.communication;

public class StoreTest {
    public static void main(String[] args) {

        Store store = new Store();
        //十个生产者，每个生产者生产200次；
        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                for (int j = 0; j < 200; j++) {
                    store.put();
                }
            }).start();
        }

        //十个消费者,每个消费者消费200次；
        for (int i = 0; i < 10; i++) {
            new Thread(() ->{
                for (int j = 0; j < 200; j++) {
                    store.get();
                }
            }).start();
        }
    }
}
```

**面试题：sleep() 与 wait()区别：**

1. sleep是Thread的静态方法，wait是Object的实例方法；
2. sleep可以在任意地方调用，wait只能出现在synchronized修饰的同步方法或同步代码块中；
3. sleep不会释放锁（抱着🔒睡），wait会使得当前线程释放对象锁。



#### 6.1.2 使用ReentrantLock实现

- 借助Condition接口：**private Condition condition = lock.newCondition();**
- 让线程等待：**condition.await()**;唤醒线程：condition.signal()、**condition.signalAll()**；
- 与synchronized中的使用wait()一样，await()与signal()也只能在lock显示锁的同步块中！

```java
package Thread.communication;

import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

public class Store2 {
    private int count;
    private final int MAX = 100;//仓库最大容量 -> 可使用内存

    private ReentrantLock lock = new ReentrantLock();
    //条件对象
    private Condition condition = lock.newCondition();

    /*
    put:生产商品
     */
    public void put() {
        lock.lock();
        try {
            while (count == MAX) {
                System.out.println("仓库满了，生产者等待");
                //需要让当前线程等待，并且释放对象锁
                condition.await();
            }
            count++;
            System.out.println(Thread.currentThread().getName() + "生产了一件商品,总数为" + count);
            //唤醒消费者-唤醒等待池中的线程
            //condition.signal();
            condition.signalAll();

        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
    /*
    get:消费商品
     */
    public void get() {

        lock.lock();
        try {
            while (count == 0) {
                System.out.println("仓库空了，消费者等待");
                condition.await();
            }
            count--;
            System.out.println(Thread.currentThread().getName() + "消费了一件商品,总数为" + count);
            //唤醒消费者-唤醒等待池中的线程
            //condition.signal();
            condition.signalAll();

        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
}

```

## 七、多线程中的三个核心概念

📕😀

1. **原子性**：多个操作不可再分 不能被打断；多个操作要么全被完成，要么不执行；
   - synchronized、ReenentrantLock都可以做到原子性；
   - 原子性类，如AtomicInteger，缺点是只能维护一个共享变量的原子性操作
2. **可见性**：一个线程对共享内存的修改，其它线程可以看见
   - synchronized、ReenentrantLock都可以做到可见性；
   - volatile也可以做到可见性；关键字volatile：用来修饰成员变量，保证此成员变量在多线程之间的可见性，保证线程每次都必须从主存获取最新值（强制）；强制线程对成员变量的改动后要立刻刷新回主存；（做不到原子性）
3. **有序性**：
   - 指令的执行顺序和编码顺序不一定一致；
   - JVM会对指令进行重新排序，以提升指令的执行性能；
   - JVM保证在单线程情况下，程序不会有任务问题，但多线程不保证；
   - volatile可以禁止JVM进行指令重排；

🦆：**double-check：使用 volatile 关键字来保证多线程下的单例：**

关于double-check，参考：[Java中的双重检查锁（double checked locking） 

[- Decouple - 博客园 (cnblogs.com)](https://www.cnblogs.com/xz816111/p/8470048.html)

```java
//单例
public class Singleton { 
  private volatile Singleton instance = null; //volatile禁止JVM指令重排，保证 new Singleton()的3步指令有序执行
  public Singleton getInstance() { 
    if (instance == null) { 
      synchronized(this) { 
        if (instance == null) { 
            //new 分3步
            //1、分配空间，给对象找内存
            //2、创建对象，给成员变量赋初始值
            //3、引用赋值 
            // JVM可能对这三步进行重排
          instance = new Singleton(); 
        } 
      } 
    } 
    return instance; 
  } 
}
```



## 八、单例模式

- 单例模式是 Java 中最简单的设计模式之一，它是指**一个类在运行期间始终只有一个实例**，我们就把它称之为单例模式。

- 单例的实现分为**饿汉模式**和**懒汉模式**

#### 8.1 饿汉模式

- 顾名思义，饿汉模式就好比他是一个饿汉，而且有一定的危机意识，他会提前把食物囤积好，以备饿了之后直接能吃到食物。对应到程序中指的是，**在类加载时就会进行单例的初始化**，以后访问时直接使用单例对象即可。

```java
public class Singleton {
    // 声明私有对象
    private static Singleton instance = new Singleton();    
    // 获取实例（单例对象）
    public static Singleton getInstance() {
        return instance;
    }
    private Singleton() {
    }
    // 方法
    public void sayHi() {
        System.out.println("Hi,Java.");
    }
}
class SingletonTest {
    public static void main(String[] args) {
        // 调用单例对象
        Singleton singleton = Singleton.getInstance();
        // 调用方法
        singleton.sayHi();
    }
}
```

- **饿汉模式优点：**
  - 线程安全：因为单例对象在类加载的时候已经被初始化了，所以线程在调用单例对象时只是把已创建好的对象赋值给变量；

- **饿汉模式缺点：**
  - 容易造成资源浪费：如果类加载了对象（对象被创建了），但一直没有被使用，这样就造成了资源浪费。

#### 8.2 懒汉模式

- 顾名思义他比较懒，每次只有需要吃饭的时候，才出去找饭吃，而不是像饿汉那样早早把饭准备好。对应到程序中指的是，当**每次需要使用实例时，再去创建获取实例，而不是在类加载时就将实例创建好。**

```java
public class Singleton {
    // 声明私有对象
    private static Singleton instance;
    // 获取实例（单例对象）
    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
    private Singleton() {
    }
    // 方法
    public void sayHi() {
        System.out.println("Hi,Java.");
    }
}
class SingletonTest {
    public static void main(String[] args) {
        Singleton singleton = Singleton.getInstance();
        singleton.sayHi();
    }
}
```

- **懒汉模式优点：**
  - 不会造成资源的浪费，因为在调用的时候才会创建实例对象；

- **懒汉模式缺点：**

  - 多线程环境下时非线程安全的，比如多个线程同时执行到if判断处，此时判断结果都是未被初始化，那么这些线程会同时创建n个实例

  可通过**synchronized + 双重锁机制**去改进懒汉模式！

## 九、线程池

- 解决频繁创建线程和销毁线程的性能损耗
- 提前先创建好一批线程，任务只需要提交给线程，threadpool会从池子中挑选线程去执行任务；执行任务结束之后继续回到池子中，接下一个任务；
- 当线程池销毁的时候，才回去结束其中的线程；
- 资源重复利用，对性能的提升；

#### 1、创建线程池方式：

- **线程个数固定：**`ExecutorService executorService = Executors.newFixedThreadPool(5);`****

- ##### **线程个数可伸缩：**`Executors.newCachedThreadPool();`🐖：池子中60s内没被使用的线程会从缓存中被销毁；

- **单个线程：**`Executors.newSingleThreadExecutor()；`适合用来做串行化任务；

- **定时线程：**`Executors.newScheduledThreadPool(5);`

  - 延时任务（延长2s执行）：

    ```java
        ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(2);
                //延时任务
        scheduledExecutorService.schedule(new Runnable() {
            @Override
            public void run() {
                System.out.println(Thread.currentThread().getName() + "执行");
            }
        },2,TimeUnit.SECONDS);
    ```

  - 定时任务（定期执行任务）：

    ```java
        scheduledExecutorService.scheduleAtFixedRate(new Runnable() {
            @Override
            public void run() {
                System.out.println(Thread.currentThread().getName() + "执行");
            }
        },2,1,TimeUnit.SECONDS);
    ```

#### 2、向线程池提交任务(**.submit()**)：

- `executorService.submit(Runnable Task)->无返回值`

- `executorService.submit(Callable<T> Task)->有返回值(Future类)` 

  ```java
          Future<String> submit = executorService.submit(new Callable<String>() {
              @Override
              public String call() throws Exception {
                  return "";
              }
          });
  ```

- `executorService.execute(new Runnable() {})`(常用前两种)

#### 3、停止线程池：

`executorService.shutdown();`

**线程池示例1：**

```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ThreadPoolTest {
    public static void main(String[] args) {
        ExecutorService executorService = Executors.newFixedThreadPool(5);

        //
        for (int i = 0; i < 10; i++) {
            executorService.submit(() -> {
                System.out.println(Thread.currentThread().getName() + "执行了");
            });
        }

        executorService.shutdown();
    }
}
/*
pool-1-thread-2执行了
pool-1-thread-5执行了
pool-1-thread-1执行了
pool-1-thread-4执行了
pool-1-thread-5执行了
pool-1-thread-1执行了
pool-1-thread-5执行了
pool-1-thread-4执行了
pool-1-thread-1执行了
pool-1-thread-3执行了
*/
```

#### 4、线程池的真正使用：

🐖🐖🐖：以上几种创建线程池方式其实并不用，因为都有各自的缺陷！

- `newFixedThreadPool`：没有非核心线程，且阻塞队列使用的是`LinkedBlockingQueue<>()`->链表没有长度限制，并发量高时容易导致内存溢出(Out of Memory)！
- `newCachedThreadPool`：没有核心线程，最大线程数是int的最大值0xfffffff(21亿)，且阻塞队列使用的是`SynchronousQueue<Runnable>()`不存储任务->会一直创建线程，直到用完CPU最大的线程数，会报错：unable to create new native thread

🐧所以要自己配置线程池的核心参数！

**真正使用的是：**`new ThreadPoolExecutor(……)`：

**线程池的核心参数：**

- `int corePoolSize`：核心线程数

- `int maximumPoolSize`：最大线程个数

- `long keepAliveTime`：非核心线程最大空闲时间

- `TimeUnit unit`：空闲时间单位

- `BlockingQueue<Runnable> workQueue`：//存放任务的阻塞队列

  ​	BlockingQueue实现类：

  ​		`new ArrayBlockingQueue<>(capacity)`

  ​		……

```java
public ThreadPoolExecutor(int corePoolSize,//核心线程数
                          int maximumPoolSize,//最大线程个数
                          long keepAliveTime,//非核心线程最大空闲时间
                          TimeUnit unit,//空闲时间单位
                          BlockingQueue<Runnable> workQueue) {//阻塞队列
    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
         Executors.defaultThreadFactory(), defaultHandler);
}
```

操作步骤：

- 当提交任务到线程池时，先判断目前核心线程数量是否已经达到，如果线程数量已经达到核心数量，则把任务放入任务队列中;
- 如果未达到核心数量，则创建核心线程去执行任务;
- 如果任务队列已满而此时尚未达到最大线程数量，则创建非核心线程去执行任务;
- **如果任务队列已满而且线程数量已达到最大线程数量，则直接拒绝任务**;

**示例（ThreadPoolExecutor）：**

```java
public static void main(String[] args) {

    ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(3,
                                                                   10,
                                                                   2,TimeUnit.SECONDS,
                                                                   new ArrayBlockingQueue<>(3));
    for (int i = 0; i < 14; i++) {//任务总数超过最大线程个数与阻塞队列长度后，多余的任务会被拒绝
        threadPoolExecutor.submit(new Runnable() {
            @Override
            public void run() {
                System.out.println(Thread.currentThread().getName() + "执行");
                try {
                    TimeUnit.SECONDS.sleep(3L);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });
    }
}
```



**配置线程池核心参数时的关注点：**

1. 任务分为CPU密集型任务（大量的计算）和IO密集型任务（大量的读写）；
2. CPU密集型任务：线程数量 = CPU核数 + 1；
3. IO密集型任务：线程数量 = CPU核数 * 2；



## 十、解决线程安全问题的思路

解决线程安全问题的思路有以下：

- 能不能保证操作的原子性，考虑Atomic包下的类够不够我们使用。
- 能不能保证操作的可见性，考虑volatile关键字够不够我们使用
- 如果涉及到对线程的控制（比如一次能使用多少个线程，当前线程触发的条件是否依赖其他线程的结果），考虑CountDownLatch/Semaphore等等。
- 如果是集合，考虑java.util.concurrent包下的集合类。
- 如果synchronized无法满足，考虑lock包下的类



## 十一、Threadlocal

![image-20220809102928288](D:\算法Typora\picture\image-20220809102928288.png)

### 一、简介

​	ThreadLocal叫做**线程变量**，意思是ThreadLocal中**填充的变量**属于**当前线程**，该变量对其他线程而言是隔离的，也就是说该变量是当

前线程独有的变量。`ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。`

ThreadLoal 变量，线程局部变量，同一个 ThreadLocal 所包含的对象，在不同的 Thread 中有不同的副本。这里有几点需要注意：

- 因为每个 Thread 内有自己的实例副本，且**该副本只能由当前 Thread 使用**。这是也是 ThreadLocal 命名的由来。
- 既然每个 Thread 有自己的实例副本，且其它 Thread 不可访问，那就**不存在多线程间共享的问题。**

​	ThreadLocal 提供了线程本地的实例。它与普通变量的区别在于，每个使用该变量的线程都会初始化一个完全独立的实例副本；

ThreadLocal 变量通常被private static修饰。当一个线程结束时，它所使用的所有 ThreadLocal 相对的实例副本都可被回收。

总的来说，**ThreadLocal 适用于每个线程需要自己独立的实例且该实例需要在多个方法中被使用，也即变量在线程间隔离而在方法或类间共享**

**的场景**

### 二、ThreadLocal与Synchronized的区别

`ThreadLocal<T>`其实是与**线程绑定的一个变量**。ThreadLocal和Synchronized都用于解决多线程并发访问。

但是ThreadLocal与synchronized有本质的区别：

​	1、**Synchronized用于线程间的`数据共享`，而ThreadLocal则用于线程间的`数据隔离`。**

​	2、Synchronized是利用锁的机制，使变量或代码块在某一时该只能被一个线程访问。而ThreadLocal为每一个线程都提供了变量的副

本，使得每个线程在某一时间访问到的并不是同一个对象，这样就隔离了多个线程对数据的数据共享。而Synchronized却正好相反，它用于在

多个线程间通信时能够获得数据共享。

​	一句话理解ThreadLocal，ThreadLocal是作为当前**线程中属性**->`ThreadLocalMap集合`中的某一个Entry的key值Entry

（threadLocal,value），虽然不同的线程之间threadLocal这个key值是一样，但是不同的线程所拥有的ThreadLocalMap是独一无二

的，也就是不同的线程间同一个ThreadLocal（key）对应存储的值(value)不一样，从而到达了线程间变量隔离的目的，但是在同一个线程

中这个**value变量地址**是一样的。

### 三、ThreadLocal的简单使用

```java
public class ThreadLocaDemo {
 
    private static ThreadLocal<String> localVar = new ThreadLocal<String>();
 
    static void print(String str) {
        //打印当前线程中本地内存中本地变量的值
        System.out.println(str + " :" + localVar.get());
        //清除本地内存中的本地变量
        localVar.remove();
    }
    public static void main(String[] args) throws InterruptedException {
 
        new Thread(new Runnable() {
            public void run() {
                ThreadLocaDemo.localVar.set("local_A");
                print("A");
                //打印本地变量
                System.out.println("after remove : " + localVar.get());
               
            }
        },"A").start();
 
        Thread.sleep(1000);
 
        new Thread(new Runnable() {
            public void run() {
                ThreadLocaDemo.localVar.set("local_B");
                print("B");
                System.out.println("after remove : " + localVar.get());
              
            }
        },"B").start();
    }
}
 
A :local_A
after remove : null
B :local_B
after remove : null
 
```

### 四、ThreadLocal的原理

####   4.1 ThreadLocal的set方法：

```java
 public void set(T value) {
        //1、获取当前线程
        Thread t = Thread.currentThread();
        //2、获取线程中的属性 threadLocalMap ,如果threadLocalMap 不为空，
        //则直接更新要保存的变量值，否则创建threadLocalMap，并赋值
        ThreadLocalMap map = getMap(t);
        if (map != null)
            map.set(this, value);
        else
            // 初始化thradLocalMap 并赋值
            createMap(t, value);
    }
```

​	`ThreadLocalMap`是**ThreadLocal的内部静态类**，而它的构成主要是用Entry来保存数据 ，而且还是**继承的弱引用**。在Entry内部使用ThreadLocal作为key，使用我们设置的value作为value。

```java
  static class ThreadLocalMap {
 
        /**
         * The entries in this hash map extend WeakReference, using
         * its main ref field as the key (which is always a
         * ThreadLocal object).  Note that null keys (i.e. entry.get()
         * == null) mean that the key is no longer referenced, so the
         * entry can be expunged from table.  Such entries are referred to
         * as "stale entries" in the code that follows.
         */
        static class Entry extends WeakReference<ThreadLocal<?>> {
            /** The value associated with this ThreadLocal. */
            Object value;
 
            Entry(ThreadLocal<?> k, Object v) {
                super(k);
                value = v;
            }
        }
 
        
    }
```

​	createMap:

```java
//这个是threadlocal 的内部方法
void createMap(Thread t, T firstValue) {
        t.threadLocals = new ThreadLocalMap(this, firstValue);
    }
 
 
    //ThreadLocalMap 构造方法
ThreadLocalMap(ThreadLocal<?> firstKey, Object firstValue) {
            table = new Entry[INITIAL_CAPACITY];
            int i = firstKey.threadLocalHashCode & (INITIAL_CAPACITY - 1);
            table[i] = new Entry(firstKey, firstValue);
            size = 1;
            setThreshold(INITIAL_CAPACITY);
        }
```

####  4.2 ThreadLocal的get方法

```java
    public T get() {
        //1、获取当前线程
        Thread t = Thread.currentThread();
        //2、获取当前线程的ThreadLocalMap
        ThreadLocalMap map = getMap(t);
        //3、如果map数据为空，
        if (map != null) {
            //3.1、获取threalLocalMap中存储的值
            ThreadLocalMap.Entry e = map.getEntry(this);
            if (e != null) {
                @SuppressWarnings("unchecked")
                T result = (T)e.value;
                return result;
            }
        }
        //如果是数据为null，则初始化，初始化的结果，TheralLocalMap中存放key值为threadLocal，值为null
        return setInitialValue();
    }
 
 
private T setInitialValue() {
        T value = initialValue();
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null)
            map.set(this, value);
        else
            createMap(t, value);
        return value;
    }
```

#### 4.3 ThreadLocal的remove方法

```java
 public void remove() {
         ThreadLocalMap m = getMap(Thread.currentThread());
         if (m != null)
             m.remove(this);
     }
```

​	为什么要删除，这涉及到**内存泄露**的问题

​	📕：实际上 ThreadLocalMap 中使用的 **key 为 ThreadLocal 的弱引用**，弱引用的特点是，如果这个对象只存在弱引用，那么在下一次垃圾回收的时候必然会被清理掉。

​	所以如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候会被清理掉的，这样一来 ThreadLocalMap中使用这个 ThreadLocal 的 key 也会被清理掉。但是，**value 是强引用**，不会被清理，这样一来就**`会出现 key 为 null 的 value`**。

​	ThreadLocal其实是与线程绑定的一个变量，如此就会出现一个问题：如果没有将ThreadLocal内的变量删除（remove）或替换，它的生命周期将会与线程共存。通常线程池中对线程管理都是采用线程复用的方法，在线程池中线程很难结束甚至于永远不会结束，这将意味着线程持续的时间将不可预测，甚至与JVM的生命周期一致。举个例子，**如果ThreadLocal中直接或间接包装了集合类或复杂对象，每次在同一个ThreadLocal中取出对象后，再对内容做操作，那么内部的集合类和复杂对象所占用的空间可能会开始持续膨胀。**

#### 4.4、ThreadLocal与Thread，ThreadLocalMap之间的关系

<img src="D:\算法Typora\picture\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA0NDUzMDE=,size_16,color_FFFFFF,t_70.png" alt="img" style="zoom:67%;" />

1. 每个Thread线程内部都有一个Map (ThreadLocalMap)
2. Map里面存储ThreadLocal对象(key)和线程的变量副本(value)
3. Thread内部的Map是由ThreadLocal维护的，由ThreadLocal负责向map获取和设置线程的变量值。
4. 对于不同的线程，每次获取副本值时，别的线程并不能获取到当前线程的副本值，形成了副本的隔离,互不干扰。

🐧从这个图中我们可以非常直观的看出，**ThreadLocalMap其实是Thread线程的一个属性值**，而**ThreadLocal是维护ThreadLocalMap**

**这个属性指的一个工具类**。**Thread线程可以拥有多个ThreadLocal维护的自己线程独享的共享变量**（这个共享变量只是针对自己线程里面共享）

### 五、ThreadLocal 常见使用场景

1. 每个线程需要有自己单独的实例
2. 实例**需要在多个方法中共享**，但不希望被多线程共享

**场景一、存储用户Session**

```java
private static final ThreadLocal threadSession = new ThreadLocal();
 
    public static Session getSession() throws InfrastructureException {
        Session s = (Session) threadSession.get();
        try {
            if (s == null) {
                s = getSessionFactory().openSession();
                threadSession.set(s);
            }
        } catch (HibernateException ex) {
            throw new InfrastructureException(ex);
        }
        return s;
    }
```

**场景二、数据库连接，处理数据库事务**

**场景三、数据跨层传递（controller,service, dao）**

 	每个线程内需要保存类似于全局变量的信息（例如在拦截器中获取的用户信息），可以让不同方法直接使用，避免参数传递的麻烦却不想被多线程共享（因为不同线程获取到的用户信息不一样）。

​	例如，用 ThreadLocal 保存一些业务内容（用户权限信息、从用户系统获取到的用户名、用户ID 等），这些信息在同一个线程内相同，但是不同的线程使用的业务内容是不相同的。

​	在线程生命周期内，都通过这个静态 ThreadLocal 实例的 get() 方法取得自己 set 过的那个对象，避免了将这个对象（如 user 对象）作为参数传递的麻烦。

​	比如说我们是一个用户系统，那么当一个请求进来的时候，一个线程会负责执行这个请求，然后这个请求就会依次调用service-1()、service-2()、service-3()、service-4()，这4个方法可能是分布在不同的类中的。这个例子和存储session有些像。
**场景四、Spring使用ThreadLocal解决线程安全问题** 

### 六、内存泄漏问题

 	Entry将ThreadLocal作为Key，值作为value保存，它继承自`WeakReference`，注意构造函数里的第一行代码super(k)，这意味着**ThreadLocal对象是一个「弱引用」**

主要两个原因
1 . 没有手动删除这个 Entry
2 . CurrentThread 当前线程依然运行

 第一点很好理解，只要在使用完下 ThreadLocal ，调用其 remove 方法删除对应的 Entry ，就能避免内存泄漏。

 第二点稍微复杂一点，由于ThreadLocalMap 是 Thread 的一个属性，被当前线程所引用，所以ThreadLocalMap的生命周期跟 Thread 一样长。**如果threadlocal变量被回收，那么当前线程的threadlocal 变量副本指向的就是key=null**, 也即**entry(null,value)**,那这**个entry对应的value永远无法访问到**。实际私用ThreadLocal场景都是采用**线程池**，而线程池中的**线程都是复用**的，这样就可能**导致非常多的entry(null,value)出现，从而导致内存泄露。**


❓：为什么不将key设置为强引用？

​	如果key设计成强引用且没有手动remove()，那么key会和value一样伴随线程的整个生命周期。

​    假设在业务代码中使用完ThreadLocal, ThreadLocal ref被回收了，但是因为threadLocalMap的Entry**强引用**了threadLocal(key就是threadLocal), **造成ThreadLocal无法被回收**。在没有手动删除Entry以及CurrentThread(当前线程)依然运行的前提下, **始终有强引用链**CurrentThread Ref → CurrentThread →Map(ThreadLocalMap)-> entry, Entry就不会被回收( Entry中包括了ThreadLocal实例和value), 导致Entry内存泄漏；也就是说: **ThreadLocalMap中的key使用了强引用, 是无法完全避免内存泄漏的。**


❓：那么为什么使用弱引用呢？

​	事实上，在 ThreadLocalMap 中的set/getEntry 方法中，会对 key 为 null（也即是 ThreadLocal 为 null ）进行判断，如果为 null 的话，那么会把 value 置为 null 的．这就意味着使用threadLocal , CurrentThread 依然运行的前提下，**就算忘记调用 remove 方法，弱引用比强引用可以多一层保障：弱引用的 ThreadLocal 会被回收,**对应value在下一次 ThreadLocal 调用 get()/set()/remove() 中的任一方法的时候会被清除，从而避免内存泄漏.

📕：ThreadLocal#set方法最终调用ThreadLocalMap#set方法，如果key==null, 会调用`replaceStaleEntry`这个方法，里面有段代码
```java
// If key not found, put new entry in stale slot
tab[staleSlot].value = null;
```



❓：如何正确使用ThreadLocal？

 1、**将ThreadLocal变量定义成private static**的，这样的话ThreadLocal的生命周期就更长，由于一直存在ThreadLocal的强引用，所以ThreadLocal也就不会被回收，也就能保证任何时候都能根据ThreadLocal的弱引用访问到Entry的value值，然后remove它，防止内存泄露

 2、每次使用完ThreadLocal，都调用它的remove()方法，清除数据。

**补充：**为了解决因使用不当可能存在的内存泄漏问题，Doug Lea大师还是做了一些改进来尽可能的避免出现内存泄露，就是方法`cleanSomeSlots、expungeStaleEntry、replaceStaleEntry`

从源码深入详解ThreadLocal内存泄漏问题：https://www.jianshu.com/p/dde92ec37bd1
