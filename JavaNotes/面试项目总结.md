# 基于Redis点评项目总结

![image-20220809205324664](D:\算法Typora\picture\image-20220809205324664.png)

## 短信登录

这一块使用redis**共享session**来实现

**发送验证码：**

用户在提交手机号后，会校验手机号是否合法，如果不合法，则要求用户重新输入手机号

如果手机号合法，后台此时生成对应的验证码，同时将验证码保存至Redis，然后再通过短信的方式将验证码发送给用户

**短信验证码登录、注册：**

用户将验证码和手机号进行输入，后台从session中拿到当前验证码，然后和用户输入的验证码进行校验，如果不一致，则无法通过校验，如果一致，则后台根据手机号查询用户，如果用户不存在，则为用户创建账号信息，保存到数据库，无论是否存在，都会将用户信息保存到session中，方便后续获得当前登录信息

**校验登录状态:**

用户在请求时候，会从cookie中携带者JsessionId到后台，后台通过JsessionId从session中拿到用户信息，如果没有session信息，则进行拦截，如果有session信息，则**将用户信息保存到threadLocal**中，并且放行；

📕：在threadLocal中，无论是他的put方法和他的get方法， 都是先从获得当前用户的线程，然后从线程中取出线程的成员变量map，只要线程不一样，map就不一样，所以可以通过这种方式来做到**线程隔离**

### 1、用到的方法和工具：

- 生成验证码时用的是`hutool`工具包：`RandomUtil.randomNumbers(6)`;
- 注入Redis时使用的是`StringRedisTemplate`；
- 发送验证码 由于需要借助第三方服务器，暂时用log代替:`log.debug("发送短信验证码成功，验证码：{}",code);`这里使用的Log仓库是**Slf4j**

​	PS❓:为什么使用Slf4j:**slf4j就是各种接口的集合**，对外暴露相同的接口，用户可以使用自己指定的日志系统。一句话总结，**slf4j让你的代码独立于任何特定的日志系统API。**这样的特性，尤其适合于公共的库的开发

- 将User对象转为Hash存储至Redis时，借助hutool中的BeanUtil来转换；
- 拦截器是实现了spring中`web.servlet.HandlerInterceptor`，重写了前置拦截和销毁拦截（销毁即移除用户的ThreadLocal，避免内存泄漏）；让拦截器生效是在Config中实现一个`MvcConfig implements WebMvcConfigurer`（@Configuration），并重写其`addInterceptors`方法；
- 返回用户信息给浏览器时需隐藏用户的敏感信息，新建一个UserDTO对象->只有id、nickName、icon
- 根据手机号查询用户：`query().eq("phone", phone).one();`利用MybatisPlus提供的便捷查询

### 2、Session共享问题：

​	问题：每个tomcat中都有一份属于自己的session,假设用户第一次访问第一台tomcat，并且把自己的信息存放到第一台服务器的session中，但是第二次这个用户访问到了第二台tomcat，那么在第二台服务器上，肯定没有第一台服务器存放的session，所以此时 整个登录拦截功能就会出现问题；早期的方案是session拷贝

​	解决：利用Redis的特性：数据共享、内存存储、key-value结构

- 首先考虑使用哪种数据结构？
  - 如果使用String，同学们注意他的value，用多占用一点空间；
  - 如果使用哈希，则他的value中只会存储他数据本身，且每个字段独立存储，方便CRUD；
- 对于key的设计：为了保护隐私，在后台生成一个随机串token，然后让前端带来这个token
- 基于Redis实现共享Session流程如下：

![image-20220809214116868](D:\算法Typora\picture\image-20220809214116868.png)

### 3、解决状态登录刷新问题

​	问题：单个拦截器只是拦截需要被拦截的路径，**假设当前用户访问了一些不需要拦截的路径**，那么这个拦截器就不会生效，所以此时**令牌刷新的动作实际上就不会执行**，所以这个方案他是存在问题的；

​	优化方案：再添加一个拦截器，**第一个拦截器中拦截所有的路径**，把第二个拦截器做的事情放入到第一个拦截器中，同时刷新令牌，因为第一个拦截器有了threadLocal的数据，所以此时**第二个拦截器只需要判断拦截器中的user对象是否存在即可**，完成整体刷新功能。

## 商户查询缓存

通过本章节，我们会理解缓存击穿，缓存穿透，缓存雪崩等问题，让小伙伴的对于这些概念的理解不仅仅是停留在概念上，更是能在代码中看到对应的内容



1000次压测结果：

![image-20220810155553079](D:\算法Typora\picture\image-20220810155553079.png)

1000次请求时Log中只查询了一次：说明加锁成功 能解决缓存击穿问题

![image-20220810155711860](D:\算法Typora\picture\image-20220810155711860.png)

## 优惠卷秒杀

通过本章节，我们可以学会Redis的计数器功能， 结合Lua完成高性能的redis操作，同时学会Redis分布式锁的原理，包括Redis的三种消息队列

## 达人探店

基于List来完成点赞列表的操作，同时基于SortedSet来完成点赞的排行榜功能

## 附近的商户

我们利用Redis的GEOHash来完成对于地理坐标的操作

## UV统计

主要是使用`HyperLogLog`（用了调和平均数）来完成统计功能

统计原理参考：https://juejin.cn/post/6844903785744056333#heading-0

- 作用是能够提供**不精确的去重计数**
- 能够使用极少的内存来统计巨量的数据，在 `Redis` 中实现的 `HyperLogLog`，只需要`12K`内存就能统计`2^64`个数据。
- 计数存在一定的误差，误差率整体较低。标准误差为**0.81%** ->经过数学统计！ 
- 误差可以被设置`辅助计算因子`进行降低
- 统计背景：伯努利实验 抛硬币(最大的抛掷次数`k`)

### Redis 中的 HyperLogLog 原理

对于命令：`pfadd key value`

​	在存入时，value 会被 hash 成 64 位，即 64 bit 的比特字符串，**前 14 位用来分桶**，前 14 位的二进制转为 10 进制就是桶标号。

​	之所以选 `14位` 来表达桶编号是因为，分了 16384 个桶，而 2^14 = 16384，刚好地，最大的时候可以把桶利用完，不造成浪费。假设一个字符串的前 14 位是：00 0000 0000 0010，其十进制值为 2。那么 index 将会被转化后放到编号为 2 的桶；

index 的转化规则：

首先因为完整的 value 比特字符串是 64 位形式，减去 14 后，剩下 50 位，那么极端情况，出现 1 的位置，是在第 50 位，即位置是 50。此时 index = 50。此时先将 index 转为 2 进制，它是：110010 。

因为16384 个桶中，每个桶是 6 bit 组成的。刚好 110010 就被设置到了第 2 号桶中去了。请注意，50 已经是最坏的情况，且它都被容纳进去了。那么其他的不用想也肯定能被容纳进去。

因为 fpadd 的 key 可以设置多个 value。例如下面的例子：

```
pfadd lgh golang
pfadd lgh python
pfadd lgh java
```

根据上面的做法，不同的 value，会被设置到不同桶中去，如果出现了在同一个桶的，即前 14 位值是一样的，但是后面出现 1 的位置不一样。那么比较原来的 index 是否比新 index 大。是，则替换。否，则不变。

最终地，一个 key 所对应的 16384 个桶都设置了很多的 value 了，每个桶有一个`k_max`。此时调用 pfcount 时，按照前面介绍的估算方式，便可以计算出 key 的设置了多少次 value，也就是统计值。

value 被转为 64 位的比特串，最终被按照上面的做法记录到每个桶中去。64 位转为十进制就是：2^64，`HyperLogLog` 仅用了：`16384 * 6 /8 / 1024 K` 存储空间就能统计多达 2^64 个数。

### 偏差修正

在估算的计算公式中，`constant` 变量不是一个定值，它会根据实际情况而被分支设置，例如下面的样子。

假设：m为分桶数，p是m的以2为底的对数。

```ini
// m 为桶数
switch (p) {
   case 4:
       constant = 0.673 * m * m;
   case 5:
       constant = 0.697 * m * m;
   case 6:
       constant = 0.709 * m * m;
   default:
       constant = (0.7213 / (1 + 1.079 / m)) * m * m;
}
```

1460992