# çŸ¥è¯†ç‚¹

| **åŒæŒ‡é’ˆã€æ»‘åŠ¨çª—å£**                        | ğŸ•    |
| ------------------------------------------- | ---- |
| **æ’åºï¼ˆè‡ªå®šä¹‰Comparatorï¼‰+æ’åºç®—æ³•çš„åº”ç”¨** | ğŸ•    |
| **ä½è¿ç®—ã€è¿›åˆ¶è½¬æ¢**                        |      |
| **äºŒåˆ†æœç´¢ã€å½’å¹¶**                          |      |
| **BFSã€DFS**                                |      |
| **å›æº¯ç®—æ³•**ã€é€’å½’                          |      |
| **è´ªå¿ƒ**                                    |      |
| **æ ˆ+å•è°ƒæ ˆ**                               |      |
| **äºŒå‰æ ‘**ï¼ˆè€ƒå¯Ÿæ„å»ºå’Œéå†ï¼‰                | ğŸ•    |
| **é˜Ÿåˆ—ã€ä¼˜å…ˆé˜Ÿåˆ—ï¼ˆå·¥ä½œçº§ä¸è¦æ±‚ï¼‰**          |      |
| **è‚¡ç¥¨ä¹°å–é—®é¢˜**                            |      |
| **åŒºé—´æ±‚å’Œé—®é¢˜ã€å‰ç¼€å’Œã€æ ‘çŠ¶æ•°ç»„ã€çº¿æ®µæ ‘**  |      |
| **åŠ¨æ€è§„åˆ’ï¼ˆå·¥ä½œçº§ä¸è¦æ±‚ï¼‰**                |      |

æ¶‰åŠçš„æ•°æ®ç»“æ„ä¸ç®—æ³•ï¼š

1. è¿›åˆ¶ä¸ä½è¿ç®—ï¼›
2. åŸºç¡€çš„æ•°æ®ç»“æ„ï¼ˆå­—ç¬¦ä¸²ã€æ•°ç»„ã€é˜Ÿåˆ—ã€æ ˆã€é“¾è¡¨ã€å“ˆå¸Œï¼‰ï¼›
3. é«˜çº§æ•°æ®ç»“æ„ï¼ˆæ ‘ï¼‰ï¼›
4. ä¼˜å…ˆé˜Ÿåˆ—ã€å›¾ï¼›
5. æ’åºä¸æŸ¥æ‰¾ï¼›
6. æšä¸¾ï¼ˆéå†ã€æ’åºã€ç»„åˆï¼‰ã€æ»‘åŠ¨çª—å£ã€åŒæŒ‡é’ˆã€å‰ç¼€å’Œï¼›
7. è¿­ä»£ã€é€’å½’ã€å›æº¯ã€åˆ†æ”¯ï¼ˆå½’å¹¶ã€äºŒåˆ†ï¼‰ã€æœç´¢ï¼ˆæ·±æœã€å¹¿æœï¼‰ã€è´ªå¿ƒï¼›

## åŸºç¡€çš„æ•°æ®ç»“æ„

#### [13. ç½—é©¬æ•°å­—è½¬æ•´æ•°](https://leetcode.cn/problems/roman-to-integer/)

å­—ç¬¦ä¸² + HashMap

```java
class Solution {
    public int romanToInt(String s) {
        Map<Character,Integer> roman = new HashMap<>();
        roman.put('I',1);
        roman.put('V',5);
        roman.put('X',10);
        roman.put('L',50);
        roman.put('C',100);
        roman.put('D',500);
        roman.put('M',1000);
        int res = 0;
        for(int i = 0; i<s.length()-1;i++){
            if(roman.get(s.charAt(i)) >= roman.get(s.charAt(i+1))){
                res += roman.get(s.charAt(i));
            }else{
                res -= roman.get(s.charAt(i));
            }
        }
        res += roman.get(s.charAt(s.length() - 1));
        return res;
    }
}
```

#### [6. N å­—å½¢å˜æ¢](https://leetcode.cn/problems/zigzag-conversion/)

è¯¥é¢˜æœ‰ä¸€ä¸ªå·§å¦™ç‚¹ï¼Œç”¨ä¸€ä¸ª flagåˆ¤æ–­curRowæ˜¯å¾€ä¸‹è¿˜æ˜¯å¾€ä¸Šï¼

```java
class Solution {
    public String convert(String s, int numRows) {
        StringBuilder[] res = new  StringBuilder[numRows];
        for (int i = 0; i < numRows; i++) {
            res[i] = new StringBuilder();
        }
        if (numRows == 1) return s;
        int curRow = 0;
        boolean goDown = false;
        for (char c : s.toCharArray()) {
            res[curRow].append(c);
            if (curRow == 0 || curRow == numRows - 1){//åœ¨é¦–è¡Œå’Œå°¾è¡Œå˜æ¢æ–¹å‘ï¼
                goDown = !goDown;
            }
            curRow += goDown?1:-1;
        }
        StringBuilder resF = new StringBuilder();
        for (StringBuilder sb : res) {
            resF.append(sb);
        }
        return resF.toString();
    }
}
```

#### [43. å­—ç¬¦ä¸²ç›¸ä¹˜](https://leetcode.cn/problems/multiply-strings/)

```java
class Solution {
    public String multiply(String num1, String num2) {
        int m = num1.length();
        int n = num2.length();
        int[] res = new int[m + n];
        for (int i = m - 1; i >= 0; i--) {
            for (int j = n - 1; j >= 0; j--) {
                int mul = (num1.charAt(i) - '0') * (num2.charAt(j) - '0');
                int p1 = i + j;//è¿›ä½éœ€è¦ç›¸åŠ çš„ä½ç½®
                int p2 = i + j + 1;//ç»“æœçš„ä½™æ•°
                int sum = mul + res[p2];
                res[p2] = sum % 10;
                res[p1] += sum / 10;

            }
        }
        // ç»“æœå‰ç¼€å¯èƒ½å­˜çš„ 0ï¼ˆæœªä½¿ç”¨çš„ä½ï¼‰
        int k = 0;
        while (k < res.length && res[k] == 0)
            k++;
        // å°†è®¡ç®—ç»“æœè½¬åŒ–æˆå­—ç¬¦ä¸²
        StringBuilder sb = new StringBuilder();
        for (; k < res.length; k++)
            sb.append(res[k]);
        
        String str = sb.toString();
        return str.length() == 0 ? "0" : str;
    }
    
}
```

#### [621. ä»»åŠ¡è°ƒåº¦å™¨](https://leetcode.cn/problems/task-scheduler/)

```java
class Solution {
    public int leastInterval(char[] tasks, int n) {
        int[] cnts = new int[26];
        for (char c : tasks) cnts[c - 'A']++;
        int max = 0, tot = 0;
        for (int i = 0; i < 26; i++) max = Math.max(max, cnts[i]);
        for (int i = 0; i < 26; i++) tot += max == cnts[i] ? 1 : 0;
        return Math.max(tasks.length, (n + 1) * (max - 1) + tot);
    }
}
æ­¤é¢˜ä¸ºå·§å¦™çš„æ‰¾è§„å¾‹é¢˜ç›®ï¼Œå‚è€ƒä¸‹é¢è§£æ³•
https://leetcode.cn/problems/task-scheduler/solution/by-ac_oier-3560/
```

#### [20. æœ‰æ•ˆçš„æ‹¬å·](https://leetcode.cn/problems/valid-parentheses/)

```ja
class Solution {
    public boolean isValid(String s) {
        Stack<Character> stack = new Stack<>();
        for (char c : s.toCharArray()) {
            if (c == '(' || c == '{' || c == '['){
                stack.push(c);
            }else {
                if (!stack.isEmpty() && leftOf(c) == stack.peek()){
                    stack.pop();
                }else return false;
            }
        }
        return stack.isEmpty();
    }
    char leftOf(char c) {
        if (c == '}') return '{';
        if (c == ')') return '(';
        return '[';
    }
}
```

#### [150. é€†æ³¢å…°è¡¨è¾¾å¼æ±‚å€¼](https://leetcode.cn/problems/evaluate-reverse-polish-notation/)

```java
class Solution {
    public int evalRPN(String[] tokens) {
        Stack<Integer> stk = new Stack<>();
        for (String token : tokens) {
            if ("+-*/".contains(token)) {
                // æ˜¯ä¸ªè¿ç®—ç¬¦ï¼Œä»æ ˆé¡¶æ‹¿å‡ºä¸¤ä¸ªæ•°å­—è¿›è¡Œè¿ç®—ï¼Œè¿ç®—ç»“æœå…¥æ ˆ
                int a = stk.pop(), b = stk.pop();
                switch (token) {
                    case "+":
                        stk.push(a + b);
                        break;
                    case "*":
                        stk.push(a * b);
                        break;
                    // å¯¹äºå‡æ³•å’Œé™¤æ³•ï¼Œé¡ºåºåˆ«æåäº†ï¼Œç¬¬äºŒä¸ªæ•°æ˜¯è¢«é™¤ï¼ˆå‡ï¼‰æ•°
                    case "-":
                        stk.push(b - a);
                        break;
                    case "/":
                        stk.push(b / a);
                        break;
                }
            } else {
                // æ˜¯ä¸ªæ•°å­—ï¼Œç›´æ¥å…¥æ ˆå³å¯
                stk.push(Integer.parseInt(token));
            }
        }
        // æœ€åæ ˆä¸­å‰©ä¸‹ä¸€ä¸ªæ•°å­—ï¼Œå³æ˜¯è®¡ç®—ç»“æœ
        return stk.pop();
    }
}
```

## **åŒæŒ‡é’ˆ**

#### [26. åˆ é™¤æœ‰åºæ•°ç»„ä¸­çš„é‡å¤é¡¹](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)

è®©æ…¢æŒ‡é’ˆ `slow` èµ°åœ¨åé¢ï¼Œå¿«æŒ‡é’ˆ `fast` èµ°åœ¨å‰é¢æ¢è·¯ï¼Œæ‰¾åˆ°ä¸€ä¸ªä¸é‡å¤çš„å…ƒç´ å°±èµ‹å€¼ç»™ `slow` å¹¶è®© `slow` å‰è¿›ä¸€æ­¥ã€‚è¿™æ ·ï¼Œå°±ä¿è¯äº† `nums[0..slow]` éƒ½æ˜¯æ— é‡å¤çš„å…ƒç´ ï¼Œå½“ `fast` æŒ‡é’ˆéå†å®Œæ•´ä¸ªæ•°ç»„ `nums` åï¼Œ`nums[0..slow]` å°±æ˜¯æ•´ä¸ªæ•°ç»„å»é‡ä¹‹åçš„ç»“æœã€‚

``` java
class Solution {
    public int removeDuplicates(int[] nums) {
        if(nums.length == 0){
            return 0;
        }
        int slow = 0;
        int fast = 0;
        while(fast < nums.length){
            if(nums[fast] != nums [slow]){
                slow++;
                nums[slow] = nums[fast]; 
            }
            fast++;
        }
        return slow + 1;
    }
}
```



#### **[443. å‹ç¼©å­—ç¬¦ä¸²](https://leetcode.cn/problems/string-compression/)**

**è¾¹ç•Œæ¡ä»¶å¾ˆå¤šï¼Œæ¡ˆä¾‹å®¹æ˜“å‡ºé”™**

```java
class Solution {
    public static int compress(char[] chars) {
        int left = 0;
        int right = 0;
        while (right < chars.length) {
            int index = right;//è®°å½•æ–°å­—æ¯å¼€å§‹æ—¶çš„ä½ç½®
            while(right < chars.length && chars[index] == chars[right]){
                right++;
            }
            int repeats = right - index;
            chars[left] = chars[right - 1];//éœ€è¦æ—¶åˆ»ä¿æŒleftçš„æ›´æ–°
            if(repeats == 1){
                left++;
            }else if(repeats <= 9){
                chars[left + 1] = (char)(repeats + '0');
                left += 2;
            }else{
                String num = repeats + "";
                for(int i = 0; i < num.length();i++){
                    chars[left + 1 + i] = num.charAt(i);
                }
                left += num.length() + 1;
            }
        }


        return left;
    }
}
```

#### **[5. æœ€é•¿å›æ–‡å­ä¸²](https://leetcode.cn/problems/longest-palindromic-substring/)**

**æ¯æ¬¡å¾ªç¯éƒ½å°†å­ä¸²è€ƒè™‘ä¸ºå¶æ•°é•¿åº¦å’ŒåŸºæ•°é•¿åº¦ï¼Œå–å’Œresæ¯”è¾ƒä¸‰è€…æœ€é•¿çš„å›æ–‡ä¸²**

```java
class Solution {
    public String longestPalindrome(String s) {
        String res = "";
        for(int i = 0; i<s.length();i++){
            String s1 = Palindrome(s,i,i);
            String s2 = Palindrome(s,i,i+1);
            res = res.length() > s1.length()?res:s1;
            res = res.length() > s2.length()?res:s2;
        }
        return res;
    }
    public String Palindrome(String s, int left, int right){
        while(left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)){
            left--;
            right++;
        }
        return s.substring(left+1,right);
    }
}
```

#### **[283. ç§»åŠ¨é›¶](https://leetcode.cn/problems/move-zeroes/)**

```java
class Solution {
    public void moveZeroes(int[] nums) {
        int slow = 0;
        for(int fast = 0;fast<nums.length;fast++){
            if(nums[fast]!= 0){
                nums[slow++] = nums[fast];
            }
        }
        for(int i = slow;i<nums.length;i++){
            nums[i] = 0;
        }
    }
}
```

#### **[19. åˆ é™¤é“¾è¡¨çš„å€’æ•°ç¬¬ N ä¸ªç»“ç‚¹](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)**

**è¿™ä¸ªé€»è¾‘å°±å¾ˆç®€å•äº†ï¼Œè¦åˆ é™¤å€’æ•°ç¬¬ `n` ä¸ªèŠ‚ç‚¹ï¼Œå°±å¾—è·å¾—å€’æ•°ç¬¬ `n + 1` ä¸ªèŠ‚ç‚¹çš„å¼•ç”¨ï¼Œå¯ä»¥ç”¨æˆ‘ä»¬å®ç°çš„ `findFromEnd` æ¥æ“ä½œã€‚**

**ä½¿ç”¨äº†è™šæ‹Ÿå¤´ç»“ç‚¹çš„æŠ€å·§ï¼Œä¹Ÿæ˜¯ä¸ºäº†é˜²æ­¢å‡ºç°ç©ºæŒ‡é’ˆçš„æƒ…å†µï¼Œæ¯”å¦‚è¯´é“¾è¡¨æ€»å…±æœ‰ 5 ä¸ªèŠ‚ç‚¹ï¼Œé¢˜ç›®å°±è®©ä½ åˆ é™¤å€’æ•°ç¬¬ 5 ä¸ªèŠ‚ç‚¹ï¼Œä¹Ÿå°±æ˜¯ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ï¼Œé‚£æŒ‰ç…§ç®—æ³•é€»è¾‘ï¼Œåº”è¯¥é¦–å…ˆæ‰¾åˆ°å€’æ•°ç¬¬ 6 ä¸ªèŠ‚ç‚¹ã€‚ä½†ç¬¬ä¸€ä¸ªèŠ‚ç‚¹å‰é¢å·²ç»æ²¡æœ‰èŠ‚ç‚¹äº†ï¼Œè¿™å°±ä¼šå‡ºé”™ã€‚**

**ä½†æœ‰äº†æˆ‘ä»¬è™šæ‹ŸèŠ‚ç‚¹ `dummy` çš„å­˜åœ¨ï¼Œå°±é¿å…äº†è¿™ä¸ªé—®é¢˜ï¼Œèƒ½å¤Ÿå¯¹è¿™ç§æƒ…å†µè¿›è¡Œæ­£ç¡®çš„åˆ é™¤ã€‚**

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(-1);
        dummy.next = head;
        ListNode x = findFromEnd(dummy, n + 1);
        x.next = x.next.next;
        return dummy.next;
    }
    private ListNode findFromEnd(ListNode head,int k){
        // p1 å…ˆèµ° k æ­¥
        ListNode p1 = head;
        for (int i = 0; i < k; i++) {
            p1 = p1.next;
        }
        ListNode p2 = head;
        // p1 å’Œ p2 åŒæ—¶èµ° n - k æ­¥
        while (p1!=null){
            p1 = p1.next;
            p2 = p2.next;
        }
        // p2 ç°åœ¨æŒ‡å‘ç¬¬ n - k + 1 ä¸ªèŠ‚ç‚¹ï¼Œå³å€’æ•°ç¬¬ k ä¸ªèŠ‚ç‚¹
        return p2;
    }
}
```

#### **[142. ç¯å½¢é“¾è¡¨ II](https://leetcode.cn/problems/linked-list-cycle-ii/)**

**è¿”å›é“¾è¡¨å¼€å§‹å…¥ç¯çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ã€‚ *å¦‚æœé“¾è¡¨æ— ç¯ï¼Œåˆ™è¿”å› `null`ã€‚***

**æ¯å½“æ…¢æŒ‡é’ˆ `slow` å‰è¿›ä¸€æ­¥ï¼Œå¿«æŒ‡é’ˆ `fast` å°±å‰è¿›ä¸¤æ­¥ã€‚**

**å¦‚æœ `fast` æœ€ç»ˆé‡åˆ°ç©ºæŒ‡é’ˆï¼Œè¯´æ˜é“¾è¡¨ä¸­æ²¡æœ‰ç¯ï¼›å¦‚æœ `fast` æœ€ç»ˆå’Œ `slow` ç›¸é‡ï¼Œé‚£è‚¯å®šæ˜¯ `fast` è¶…è¿‡äº† `slow` ä¸€åœˆï¼Œè¯´æ˜é“¾è¡¨ä¸­å«æœ‰ç¯ã€‚**

```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode slow = head,fast = head;
        while(fast != null && fast.next != null){
            slow = slow.next;
            fast = fast.next.next;
            if(fast == slow) break;
        }
        if(fast == null || fast.next == null){
            return null;
        }
        slow = head;
        while(slow != fast){
            slow = slow.next;
            fast = fast.next;
        }
        return slow;
    }
}
```

## æ»‘åŠ¨çª—å£

#### åŸºæœ¬ç®—æ³•æ¡†æ¶

```java
/* æ»‘åŠ¨çª—å£ç®—æ³•æ¡†æ¶ */
void slidingWindow(String s) {
    // ç”¨åˆé€‚çš„æ•°æ®ç»“æ„è®°å½•çª—å£ä¸­çš„æ•°æ®
    HashMap<Character, Integer> window = new HashMap<>();

    int left = 0, right = 0;
    while (right < s.length()) {
        // c æ˜¯å°†ç§»å…¥çª—å£çš„å­—ç¬¦
        char c = s.charAt(right);
        window.put(c, window.getOrDefault(c, 0) + 1);
        // å¢å¤§çª—å£
        right++;
        // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
        ...

        /*** debug è¾“å‡ºçš„ä½ç½® ***/
        // æ³¨æ„åœ¨æœ€ç»ˆçš„è§£æ³•ä»£ç ä¸­ä¸è¦ print
        // å› ä¸º IO æ“ä½œå¾ˆè€—æ—¶ï¼Œå¯èƒ½å¯¼è‡´è¶…æ—¶
        System.out.printf("window: [%d, %d)\n", left, right);
        /********************/

        // åˆ¤æ–­å·¦ä¾§çª—å£æ˜¯å¦è¦æ”¶ç¼©
        while (left < right && window needs shrink) {
            // d æ˜¯å°†ç§»å‡ºçª—å£çš„å­—ç¬¦
            char d = s.charAt(left);
            window.put(d, window.get(d) - 1);
            // ç¼©å°çª—å£
            left++;
            // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
            ...
        }
    }
}
```

#### [643. å­æ•°ç»„æœ€å¤§å¹³å‡æ•° I](https://leetcode.cn/problems/maximum-average-subarray-i/)

```java
    public double findMaxAverage(int[] nums, int k) {
        int sum = 0;
        int n = nums.length;
        for (int i = 0; i < k; i++) {
            sum += nums[i];
        }
        int maxSum = sum;
        for (int i = k; i < n; i++) {
            sum = sum - nums[i - k] + nums[i];
            maxSum = Math.max(maxSum, sum);
        }
        return 1.0 * maxSum / k;
    }
```



#### [76. æœ€å°è¦†ç›–å­ä¸²](https://leetcode.cn/problems/minimum-window-substring/)

```java
class Solution {
    public static String minWindow(String s, String t) {
        Map<Character, Integer> need = new HashMap<>();
        Map<Character, Integer> window = new HashMap<>();
        for (char c : t.toCharArray()) {// ç»Ÿè®¡ t ä¸­å„å­—ç¬¦å‡ºç°æ¬¡æ•°
            need.put(c, need.getOrDefault(c, 0) + 1);
        }
        int left = 0, right = 0;
        int valid = 0;// çª—å£ä¸­æ»¡è¶³éœ€è¦çš„å­—ç¬¦ä¸ªæ•°
        // è®°å½•æœ€å°è¦†ç›–å­ä¸²çš„èµ·å§‹ç´¢å¼•åŠé•¿åº¦
        int start = 0, len = Integer.MAX_VALUE;
        while (right < s.length()) {
            char c = s.charAt(right);// c æ˜¯å°†ç§»å…¥çª—å£çš„å­—ç¬¦
            right++;// æ‰©å¤§çª—å£
            if (need.containsKey(c)) {// è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
                window.put(c, window.getOrDefault(c, 0) + 1);
                if (window.get(c).equals(need.get(c))) {
                    valid++;
                }
            }
            // åˆ¤æ–­å·¦ä¾§çª—å£æ˜¯å¦è¦æ”¶ç¼©
            while (valid == need.size()) {
                if (right - left < len) {// æ›´æ–°æœ€å°è¦†ç›–å­ä¸²
                    start = left;
                    len = right - left;
                }
                char d = s.charAt(left);// d æ˜¯å°†ç§»å‡ºçª—å£çš„å­—ç¬¦
                left++;
                if (need.containsKey(d)) {// è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
                    if (window.get(d).equals(need.get(d))) {
                        valid--;
                    }
                    window.put(d, window.get(d) - 1);
                }
            }
        }
        return len == Integer.MAX_VALUE ? "" : s.substring(start, start + len);
    }
}
```

#### [567. å­—ç¬¦ä¸²çš„æ’åˆ—](https://leetcode.cn/problems/permutation-in-string/)

**ç›¸å½“ç»™ä½ ä¸€ä¸ª `S` å’Œä¸€ä¸ª `T`ï¼Œè¯·é—®ä½  `S` ä¸­æ˜¯å¦å­˜åœ¨ä¸€ä¸ªå­ä¸²ï¼ŒåŒ…å« `T` ä¸­æ‰€æœ‰å­—ç¬¦ä¸”ä¸åŒ…å«å…¶ä»–å­—ç¬¦,å…¸å‹çš„æ»‘çª—**

```java
class Solution {
    public boolean checkInclusion(String t, String s) {
        Map<Character, Integer> need = new HashMap<>();
        Map<Character, Integer> window = new HashMap<>();
        for (char c : t.toCharArray()) {
            need.put(c, need.getOrDefault(c, 0) + 1);
        }
        int left = 0 ,right = 0;
        int valid = 0;
        while (right < s.length()){
            char c = s.charAt(right);
            right++;
            if (need.containsKey(c)){
                window.put(c, window.getOrDefault(c,0)+1);
                if (window.get(c).equals(need.get(c))){
                    valid++;
                }
            }
            while (right - left >= t.length()){
                if (valid == need.size()){
                    return true;
                }
                char d = s.charAt(left);
                left++;
                if (need.containsKey(d)){
                    if (window.get(d).equals(need.get(d))){
                        valid --;
                    }
                    window.put(d, window.getOrDefault(d,0) - 1);
                }
            }
        }
        return false;
    }
}
```

#### [438. æ‰¾åˆ°å­—ç¬¦ä¸²ä¸­æ‰€æœ‰å­—æ¯å¼‚ä½è¯](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)

è·Ÿä¸Šä¸€é¢˜åŸºæœ¬ä¸€æ¨¡ä¸€æ ·ï¼Œåªæ˜¯æ¯æ¬¡æ‰¾åˆ°validçš„æ’åˆ—ï¼Œéƒ½å­˜å…¥å…¶leftï¼Œå…¶ä»–ä»£ç ä¸å˜ï¼Œå°±åªæ”¹ä¸€è¡Œ;

```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        Map<Character, Integer> need = new HashMap<>();
        Map<Character, Integer> window = new HashMap<>();
        List<Integer> res = new ArrayList<>(); // è®°å½•ç»“æœ
        for (char c : p.toCharArray()) {
            need.put(c, need.getOrDefault(c, 0) + 1);
        }
        int left = 0 ,right = 0;
        int valid = 0;
        while (right < s.length()){
            char c = s.charAt(right);
            right++;
            if (need.containsKey(c)){
                window.put(c, window.getOrDefault(c,0)+1);
                if (window.get(c).equals(need.get(c))){
                    valid++;
                }
            }
            while (right - left >= p.length()){
                if (valid == need.size()){
                    res.add(left);
                }
                char d = s.charAt(left);
                left++;
                if (need.containsKey(d)){
                    if (window.get(d).equals(need.get(d))){
                        valid --;
                    }
                    window.put(d, window.getOrDefault(d,0) - 1);
                }
            }
        }
        return res;
    }
}
```

#### [3. æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

å·¦çª—å£æ”¶ç¼©æ¡ä»¶ **window.get(c) > 1**ï¼Œæ»¡è¶³æ— é‡å¤å­—ç¬¦ï¼

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Map<Character, Integer> window = new HashMap<>();
        int left = 0, right = 0;
        int res = 0;
        while(right < s.length()){
            char c = s.charAt(right);
            right++;
            window.put(c, window.getOrDefault(c, 0) + 1);
            //å·¦çª—å£æ”¶ç¼©æ¡ä»¶
            while(window.get(c) > 1){
                char d = s.charAt(left);
                left++;
                window.put(d,window.get(d) - 1);
            }
            res = Math.max(res,right - left);//æ”¶ç¼©å®Œæˆåä¸€å®šä¿è¯çª—å£ä¸­æ²¡æœ‰é‡å¤,æ­¤æ—¶æ‰æ›´æ–°res
        }
        return res;
    }
}
```



[239. æ»‘åŠ¨çª—å£æœ€å¤§å€¼](https://leetcode.cn/problems/sliding-window-maximum/)

![img](C:\Users\Windows\Desktop\TyporaImages\1.png)

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        if(nums == null || nums.length < 2){
            return nums;
        }
        LinkedList<Integer> queue = new LinkedList<>();
        int n = nums.length;
        int[] result = new int[n - k + 1];
        for(int i = 0; i<n;i++){
            while(!queue.isEmpty() && nums[queue.peekLast()] < nums[i]){
                queue.pollLast();//å¼¹å‡ºé˜Ÿå°¾
            }
            while(!queue.isEmpty() && queue.peek() < i - k + 1){
                queue.poll();//å¼¹å‡ºé˜Ÿé¦–
            }
            queue.addLast(i);
            if(i >= k-1){
                result[i+1-k] = nums[queue.peek()];
            }
        }
        return result;
    }
}
```

## æ’åºï¼ˆé‡å†™sortï¼‰

```java
public class Sort {
    public static void main(String[] args) {
        //1ã€æ•°ç»„æ’åº
        int[] arr = {12,33,44,55,2,4,66,31};
        Arrays.sort(arr);
        //2ã€Listæ’åº
        List<Integer> list = new ArrayList<>();
        list.add(5);
        list.add(3);
        list.add(6);
        list.add(8);
        list.add(1);
        //Collections.sort(list);// List<String>ä¹Ÿå¯ä»¥ç›´æ¥sort
        Collections.sort(list,((o1, o2) -> {
            return o1 - o2;//ä»å°åˆ°å¤§
        }));
//        for (Integer integer : list) {
//            System.out.println(integer);
//        }
        //3ã€TreeMapæ’åºâ€”â€”é»˜è®¤ä»¥keyå‡åºæ’åº
        Map<String,String> map = new TreeMap<>(new Comparator<String>() {
            @Override
            public int compare(String o1, String o2) {
                return o1.compareTo(o2);
            }
        });
        map.put("c","cccc");
        map.put("a","accc");
        map.put("d","dccc");
        map.put("b","bccc");
        for (Map.Entry<String, String> entry : map.entrySet()) {
            System.out.println(entry.getKey());
        }
        //TreeMapå¯¹valueæ’åºï¼Œéœ€è¦å€ŸåŠ©Collections.sort
        Map<String,String> map2 = new TreeMap<>();
        map2.put("c","cccc");
        map2.put("a","accc");
        map2.put("d","dccc");
        map2.put("b","bccc");
        ArrayList<Map.Entry<String, String>> entries = new ArrayList<>(map2.entrySet());
        entries.sort(((o1, o2) -> o2.getValue().compareTo(o1.getValue())));
        //å¯ç®€å†™ä¸ºCollections.sort(entries,(Comparator.comparing(Map.Entry::getValue)));
        for (Map.Entry<String, String> entry : entries) {
            System.out.println(entry.getKey() + ":" + entry.getValue());
        }
        //HashmapåŒä¸Š
    }
}
```

#### [1030. è·ç¦»é¡ºåºæ’åˆ—çŸ©é˜µå•å…ƒæ ¼](https://leetcode.cn/problems/matrix-cells-in-distance-order/)

å¸¸è§„çš„æ¯”è¾ƒå™¨

```java
class Solution {
    public int[][] allCellsDistOrder(int rows, int cols, int rCenter, int cCenter) {
        ArrayList<int[]> list = new ArrayList<>();
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                int[] cordinates = new int[]{i,j};
                list.add(cordinates);
            }
        }
        list.sort(Comparator.comparingInt(o -> (Math.abs(o[0] - rCenter) + Math.abs(o[1] - cCenter))));
        int[][] res = new int[list.size()][2];
        int index = 0;
        for (int[] ints : list) {
            res[index++] = ints;
        }
        return res;
    }
}
```

#### [179. æœ€å¤§æ•°](https://leetcode.cn/problems/largest-number/)

å¯ä»¥æ ¹æ®ã€Œç»“æœã€æ¥å†³å®šaå’Œbçš„æ’åºå…³ç³»:
**å¦‚æœæ‹¼æ¥ç»“æœabè¦æ¯”baå¥½ï¼Œé‚£ä¹ˆæˆ‘ä»¬ä¼šè®¤ä¸ºaåº”è¯¥æ”¾åœ¨bå‰é¢ã€‚**
å¦å¤–ï¼Œæ³¨æ„æˆ‘ä»¬éœ€è¦å¤„ç†å‰å¯¼é›¶(æœ€å¤šä¿ç•™ä½)

```java
class Solution {
    public String largestNumber(int[] nums) {
        if (nums.length == 0){
            return "";
        }
        boolean isAllZero = true;
        List<String> numList = new ArrayList<>();
        for (int num : nums) {
            if (num != 0){
                isAllZero = false;
            }
            numList.add(String.valueOf(num));
        }
        if(isAllZero){
            return "0";
        }
        numList.sort((o1, o2) -> (o2 + o1).compareTo(o1 + o2));
        StringBuilder stringBuilder = new StringBuilder();
        for (String s : numList) {
            stringBuilder.append(s);
        }
        return stringBuilder.toString();
    }
}
```

#### [853. è½¦é˜Ÿ](https://leetcode.cn/problems/car-fleet/)

```java
class Solution {
    public int carFleet(int target, int[] position, int[] speed) {
        int carsNum = position.length;
        if(carsNum <= 1){
            return carsNum;
        }
        double[][] cars = new double[carsNum][2];//[å½“å‰é¡ºä½ï¼Œåˆ°è¾¾ç»ˆç‚¹æ—¶é—´]
        for (int i = 0; i < carsNum; i++) {
            cars[i][0] = position[i];
            cars[i][1] = (double) (target - position[i]) / speed[i];
        }
        Arrays.sort(cars,((o1, o2) -> (int) (o1[0] - o2[0])));//[ä½ç½®é å‰çš„ç¦»ç»ˆç‚¹è¿‘]
        int ans = 0;
        for (int i = carsNum - 1; i > 0; i--) {//ä¸€è¾†è½¦æ°¸è¿œä¸ä¼šè¶…è¿‡å‰é¢çš„å¦ä¸€è¾†è½¦ åªç”¨çœ‹ç›¸é‚»ä¸¤è½¦
            if (cars[i][1] < cars[i-1][1]){//å‰è½¦åˆ°è¾¾æ—¶é—´æ›´çŸ­ï¼Œåè½¦ä¸€å®šè¿½ä¸ä¸Šï¼
                ans++;
            }else {//å‰è½¦æ¯”åè½¦åˆ°è¾¾æ—¶é—´æ›´é•¿ï¼Œå®ƒå¯ä»¥è¿½ä¸Šå»ï¼Œå¹¶ä¸å‰è½¦ ä»¥ç›¸åŒçš„é€Ÿåº¦ ç´§æ¥ç€è¡Œé©¶
                cars[i-1][1] = cars[i][1];
            }
        }
        return ans + 1;
    }
}
```



## äºŒå‰æ ‘

#### [103. äºŒå‰æ ‘çš„é”¯é½¿å½¢å±‚åºéå†](https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/)

ä¸å±‚åºéå†å‡ ä¹ä¸€è‡´

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> res = new LinkedList<>();
        if(root == null){
            return res;
        }
        Queue<TreeNode> q = new LinkedList<>();
        q.offer(root);
        boolean flag = true;// ä¸º true æ—¶å‘å³ï¼Œfalse æ—¶å‘å·¦
        while(!q.isEmpty()){
            int sz = q.size();
            LinkedList<Integer> level = new LinkedList<>();
            for(int i = 0;i<sz;i++){
                TreeNode cur = q.poll();
                if(flag){
                    level.addLast(cur.val);
                }else{
                    level.addFirst(cur.val);
                }
                if(cur.left != null){
                    q.offer(cur.left);
                }
                if(cur.right != null){
                    q.offer(cur.right);
                }
            }
            flag = !flag;//ä¿®æ”¹æ–¹å‘
            res.add(level);
        }
        return res;
    }
}
```

#### [112. è·¯å¾„æ€»å’Œ](https://leetcode.cn/problems/path-sum/)

```jade
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if(root == null){
            return false;
        }
        targetSum -= root.val;
        if(root.left == null && root.right == null){//åˆ°å¶å­èŠ‚ç‚¹äº†
            return targetSum == 0;
        }
        if(root.left != null){
            boolean left = hasPathSum(root.left,targetSum);
            if(left) return true;
        }
        if(root.right != null){
            boolean right = hasPathSum(root.right,targetSum);
            if(right) return true;
        }
        return false;
    }
}
```

## å›æº¯

#### åŸºæœ¬æ¡†æ¶

```java
result = []
def backtrack(è·¯å¾„, é€‰æ‹©åˆ—è¡¨):
    if æ»¡è¶³ç»“æŸæ¡ä»¶:
        result.add(è·¯å¾„)
        return
    
    for é€‰æ‹© in é€‰æ‹©åˆ—è¡¨:
		ä¼šæœ‰æ·»åŠ å‰ªçº¸çš„æ“ä½œï¼ˆå¦‚æ’åˆ—ä¸­æœ‰é‡å¤å…ƒç´ ï¼‰
        åšé€‰æ‹©
        backtrack(è·¯å¾„, é€‰æ‹©åˆ—è¡¨)
        æ’¤é”€é€‰æ‹©

```

#### [46. å…¨æ’åˆ—](https://leetcode.cn/problems/permutations/)

å…¸å‹çš„å›æº¯æ¨¡æ¿ï¼›

```java
class Solution {
    List<List<Integer>> res = new LinkedList<>();
    /* ä¸»å‡½æ•°ï¼Œè¾“å…¥ä¸€ç»„ä¸é‡å¤çš„æ•°å­—ï¼Œè¿”å›å®ƒä»¬çš„å…¨æ’åˆ— */
    List<List<Integer>> permute(int[] nums) {
        // è®°å½•ã€Œè·¯å¾„ã€
        LinkedList<Integer> track = new LinkedList<>();
        // ã€Œè·¯å¾„ã€ä¸­çš„å…ƒç´ ä¼šè¢«æ ‡è®°ä¸º trueï¼Œé¿å…é‡å¤ä½¿ç”¨
        boolean[] used = new boolean[nums.length];        
        backtrack(nums, track, used);
        return res;
    }

    // è·¯å¾„ï¼šè®°å½•åœ¨ track ä¸­
    // é€‰æ‹©åˆ—è¡¨ï¼šnums ä¸­ä¸å­˜åœ¨äº track çš„é‚£äº›å…ƒç´ ï¼ˆused[i] ä¸º falseï¼‰
    // ç»“æŸæ¡ä»¶ï¼šnums ä¸­çš„å…ƒç´ å…¨éƒ½åœ¨ track ä¸­å‡ºç°
    void backtrack(int[] nums, LinkedList<Integer> track, boolean[] used) {
        // è§¦å‘ç»“æŸæ¡ä»¶
        if (track.size() == nums.length) {
            res.add(new LinkedList(track));
            return;
        }
        for (int i = 0; i < nums.length; i++) {
            // æ’é™¤ä¸åˆæ³•çš„é€‰æ‹©
            if (used[i]) {
                // nums[i] å·²ç»åœ¨ track ä¸­ï¼Œè·³è¿‡
                continue;
            }
            // åšé€‰æ‹©
            track.add(nums[i]);
            used[i] = true;
            // è¿›å…¥ä¸‹ä¸€å±‚å†³ç­–æ ‘
            backtrack(nums, track, used);
            // å–æ¶ˆé€‰æ‹©
            track.removeLast();
            used[i] = false;
        }
    }
}
```

####  [78. å­é›†](https://leetcode.cn/problems/subsets/)

```java
class Solution {
    List<List<Integer>> res = new LinkedList<>();
    public List<List<Integer>> subsets(int[] nums) {
        LinkedList<Integer> path = new LinkedList<>();
        backTrack(nums,0,path);
        return res;
    }
    public void backTrack(int[] nums, int start,LinkedList<Integer> path){
        res.add(new LinkedList(path));
        for(int i = start;i<nums.length;i++){
            path.add(nums[i]);
            backTrack(nums,i+1,path);
            path.removeLast();
        }
    }
}
```

#### [77. ç»„åˆ](https://leetcode.cn/problems/combinations/)

```java
class Solution {
    List<List<Integer>> res = new LinkedList<>();
    public List<List<Integer>> combine(int n, int k) {
        LinkedList<Integer> path = new LinkedList<>();
        backTrack(n,k,1,path);
        return res;

    }
     public void backTrack(int n,int k, int start,LinkedList<Integer> path){
         if(path.size() == k){
             res.add(new LinkedList(path));
         }
         for(int i = start;i<=n;i++){
             path.add(i);
             backTrack(n,k,i+1,path);
             path.removeLast();
         }
     }
}
```

#### [17. ç”µè¯å·ç çš„å­—æ¯ç»„åˆ](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)

æ­¤é¢˜ä¸ºç»„åˆæ¨¡æ¿

```java
class Solution {
    String[] mapping = new String[] {
            "", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"
    };
    List<String> res = new LinkedList<>();
    public List<String> letterCombinations(String digits) {
        if(digits.isEmpty()) return res;
        backTrack(digits,0,new StringBuilder());
        return res;
    }
    public void backTrack(String digits,int start,StringBuilder sb){
        if (sb.length() == digits.length()){
            res.add(sb.toString());
            return;
        }
        for (int i = start; i < digits.length(); i++) {
            int digit = digits.charAt(i) - '0';
            for (char c : mapping[digit].toCharArray()) {
                sb.append(c);
                backTrack(digits,i+1,sb);
                sb.deleteCharAt(sb.length()-1);
            }
        }
    }
}
```

#### [131. åˆ†å‰²å›æ–‡ä¸²](https://leetcode.cn/problems/palindrome-partitioning/)

åªæœ‰æ ‘ææ˜¯å›æ–‡ä¸²çš„æ—¶å€™æ‰ä¼šç»§ç»­å¾€ä¸‹èµ°ï¼Œç»ˆæ­¢æ¡ä»¶ä¸ºèµ°åˆ°å¶å­èŠ‚ç‚¹ï¼

<img src="https://labuladong.github.io/pictures/%E7%9F%AD%E9%A2%98%E8%A7%A3/131.jpeg" alt="img" style="zoom: 25%;" />

```java
class Solution {
    List<List<String>> res = new LinkedList<>();
    LinkedList<String> track = new LinkedList<>();

    public List<List<String>> partition(String s) {
        backtrack(s, 0);
        return res;
    }

    // å›æº¯ç®—æ³•æ¡†æ¶
    void backtrack(String s, int start) {
        if (start == s.length()) {
            // base caseï¼Œèµ°åˆ°å¶å­èŠ‚ç‚¹
            // å³æ•´ä¸ª s è¢«æˆåŠŸåˆ†å‰²ä¸ºè‹¥å¹²ä¸ªå›æ–‡å­ä¸²ï¼Œè®°ä¸‹ç­”æ¡ˆ
            res.add(new ArrayList<String>(track));
        }
        for (int i = start; i < s.length(); i++) {
            if (!isPalindrome(s, start, i)) {
                // s[start..i] ä¸æ˜¯å›æ–‡ä¸²ï¼Œä¸èƒ½åˆ†å‰²
                continue;
            }
            // s[start..i] æ˜¯ä¸€ä¸ªå›æ–‡ä¸²ï¼Œå¯ä»¥è¿›è¡Œåˆ†å‰²
            // åšé€‰æ‹©ï¼ŒæŠŠ s[start..i] æ”¾å…¥è·¯å¾„åˆ—è¡¨ä¸­
            track.addLast(s.substring(start, i + 1));
            // è¿›å…¥å›æº¯æ ‘çš„ä¸‹ä¸€å±‚ï¼Œç»§ç»­åˆ‡åˆ† s[i+1..]
            backtrack(s, i + 1);
            // æ’¤é”€é€‰æ‹©
            track.removeLast();
        }
    }

    // ç”¨åŒæŒ‡é’ˆæŠ€å·§åˆ¤æ–­ s[lo..hi] æ˜¯å¦æ˜¯ä¸€ä¸ªå›æ–‡ä¸²
    boolean isPalindrome(String s, int lo, int hi) {
        while (lo < hi) {
            if (s.charAt(lo) != s.charAt(hi)) {
                return false;
            }
            lo++;
            hi--;
        }
        return true;
    }
}
```

#### [93. å¤åŸ IP åœ°å€](https://leetcode.cn/problems/restore-ip-addresses/)

è·Ÿä¸Šä¸€é¢˜åŸºæœ¬æ¡†æ¶ä¸€æ ·ï¼Œä»…isValidå‡½æ•°æœ‰äº›è®¸ä¸åŒï¼›

```java
class Solution {

    List<String> res = new LinkedList<>();
    LinkedList<String> track = new LinkedList<>();

    public List<String> restoreIpAddresses(String s) {
        backtrack(s, 0);
        return res;
    }

    // å›æº¯ç®—æ³•æ¡†æ¶
    void backtrack(String s, int start) {
        if (start == s.length() && track.size() == 4) {
            // base caseï¼Œèµ°åˆ°å¶å­èŠ‚ç‚¹
            // å³æ•´ä¸ª s è¢«æˆåŠŸåˆ†å‰²ä¸ºåˆæ³•çš„å››éƒ¨åˆ†ï¼Œè®°ä¸‹ç­”æ¡ˆ
            res.add(String.join(".", track));
        }
        for (int i = start; i < s.length(); i++) {
            if (!isValid(s, start, i)) {
                // s[start..i] ä¸æ˜¯åˆæ³•çš„ ip æ•°å­—ï¼Œä¸èƒ½åˆ†å‰²
                continue;
            }
            if (track.size() >= 4) {
                // å·²ç»åˆ†è§£æˆ 4 éƒ¨åˆ†äº†ï¼Œä¸èƒ½å†åˆ†è§£äº†
                break;
            }
            // s[start..i] æ˜¯ä¸€ä¸ªåˆæ³•çš„ ip æ•°å­—ï¼Œå¯ä»¥è¿›è¡Œåˆ†å‰²
            // åšé€‰æ‹©ï¼ŒæŠŠ s[start..i] æ”¾å…¥è·¯å¾„åˆ—è¡¨ä¸­
            track.addLast(s.substring(start, i + 1));
            // è¿›å…¥å›æº¯æ ‘çš„ä¸‹ä¸€å±‚ï¼Œç»§ç»­åˆ‡åˆ† s[i+1..]
            backtrack(s, i + 1);
            // æ’¤é”€é€‰æ‹©
            track.removeLast();
        }
    }

    // åˆ¤æ–­ s[
    boolean isValid(String s, int start, int end) {
        int length = end - start + 1;

        if (length == 0 || length > 3) {
            return false;
        }

        if (length == 1) {
            // å¦‚æœåªæœ‰ä¸€ä½æ•°å­—ï¼Œè‚¯å®šæ˜¯åˆæ³•çš„
            return true;
        }

        if (s.charAt(start) == '0') {
            // å¤šäºä¸€ä½æ•°å­—ï¼Œä½†å¼€å¤´æ˜¯ 0ï¼Œè‚¯å®šä¸åˆæ³•
            return false;
        }

        if (length <= 2) {
            // æ’é™¤äº†å¼€å¤´æ˜¯ 0 çš„æƒ…å†µï¼Œé‚£ä¹ˆå¦‚æœæ˜¯ä¸¤ä½æ•°ï¼Œæ€ä¹ˆç€éƒ½æ˜¯åˆæ³•çš„
            return true;
        }

        // ç°åœ¨è¾“å…¥çš„ä¸€å®šæ˜¯ä¸‰ä½æ•°
        if (Integer.parseInt(s.substring(start, start + length)) > 255) {
            // ä¸å¯èƒ½å¤§äº 255
            return false;
        } else {
            return true;
        }

    }
}
```

## BFS

#### åŸºæœ¬æ¡†æ¶

**é—®é¢˜çš„æœ¬è´¨å°±æ˜¯è®©ä½ åœ¨ä¸€å¹…ã€Œå›¾ã€ä¸­æ‰¾åˆ°ä»èµ·ç‚¹ `start` åˆ°ç»ˆç‚¹ `target` çš„æœ€è¿‘è·ç¦»**

![img](https://labuladong.gitee.io/algo/images/dijkstra/1.jpeg)

```java
// è®¡ç®—ä»èµ·ç‚¹ start åˆ°ç»ˆç‚¹ target çš„æœ€è¿‘è·ç¦»
int BFS(Node start, Node target) {
    Queue<Node> q; // æ ¸å¿ƒæ•°æ®ç»“æ„
    Set<Node> visited; // é¿å…èµ°å›å¤´è·¯
    
    q.offer(start); // å°†èµ·ç‚¹åŠ å…¥é˜Ÿåˆ—
    visited.add(start);

    while (q not empty) {
        int sz = q.size();
        /* å°†å½“å‰é˜Ÿåˆ—ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹å‘å››å‘¨æ‰©æ•£ */
        for (int i = 0; i < sz; i++) {
            Node cur = q.poll();
            /* åˆ’é‡ç‚¹ï¼šè¿™é‡Œåˆ¤æ–­æ˜¯å¦åˆ°è¾¾ç»ˆç‚¹ */
            if (cur is target)
                return step;
            /* å°† cur çš„ç›¸é‚»èŠ‚ç‚¹åŠ å…¥é˜Ÿåˆ— */
            for (Node x : cur.adj()) {
                if (x not in visited) {
                    q.offer(x);
                    visited.add(x);
                }
            }
        }
    }
    // å¦‚æœèµ°åˆ°è¿™é‡Œï¼Œè¯´æ˜åœ¨å›¾ä¸­æ²¡æœ‰æ‰¾åˆ°ç›®æ ‡èŠ‚ç‚¹
}
```

#### [111. äºŒå‰æ ‘çš„æœ€å°æ·±åº¦](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)

äºŒå‰æ ‘æ²¡æœ‰ä»å­èŠ‚ç‚¹å›çˆ¶èŠ‚ç‚¹çš„è·¯å¾„ï¼Œä¸éœ€è¦è®°å½•visited

```java
class Solution {
    public int minDepth(TreeNode root) {
        if (root == null) return 0;
        Queue<TreeNode> q = new LinkedList<>();
        q.offer(root);
        int depth = 1;
        while (!q.isEmpty()) {
            int size = q.size();
            for (int i = 0; i < size; i++) {
                TreeNode cur = q.poll();
                if (cur.left == null && cur.right == null) {
                    return depth;
                }
                if (cur.left != null) {
                    q.offer(cur.left);
                }
                if (cur.right != null) {
                    q.offer(cur.right);
                }
            }
            depth++;
        }
        return depth;
    }
}
```

#### [752. æ‰“å¼€è½¬ç›˜é”](https://leetcode.cn/problems/open-the-lock/)

```java
class Solution {
    public int openLock(String[] deadends, String target) {
        // è®°å½•éœ€è¦è·³è¿‡çš„æ­»äº¡å¯†ç 
        Set<String> deads = new HashSet<>();
        for (String s : deadends) deads.add(s);
        // è®°å½•å·²ç»ç©·ä¸¾è¿‡çš„å¯†ç ï¼Œé˜²æ­¢èµ°å›å¤´è·¯
        Set<String> visited = new HashSet<>();
        Queue<String> q = new LinkedList<>();
        // ä»èµ·ç‚¹å¼€å§‹å¯åŠ¨å¹¿åº¦ä¼˜å…ˆæœç´¢
        int step = 0;
        q.offer("0000");
        visited.add("0000");

        while (!q.isEmpty()) {
            int sz = q.size();
            /* å°†å½“å‰é˜Ÿåˆ—ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹å‘å‘¨å›´æ‰©æ•£ */
            for (int i = 0; i < sz; i++) {
                String cur = q.poll();

                /* åˆ¤æ–­æ˜¯å¦åˆ°è¾¾ç»ˆç‚¹ */
                if (deads.contains(cur))
                    continue;
                if (cur.equals(target))
                    return step;

                /* å°†ä¸€ä¸ªèŠ‚ç‚¹çš„æœªéå†ç›¸é‚»èŠ‚ç‚¹åŠ å…¥é˜Ÿåˆ— */
                for (int j = 0; j < 4; j++) {
                    String up = plusOne(cur, j);
                    if (!visited.contains(up)) {
                        q.offer(up);
                        visited.add(up);
                    }
                    String down = minusOne(cur, j);
                    if (!visited.contains(down)) {
                        q.offer(down);
                        visited.add(down);
                    }
                }
            }
            /* åœ¨è¿™é‡Œå¢åŠ æ­¥æ•° */
            step++;
        }
        // å¦‚æœç©·ä¸¾å®Œéƒ½æ²¡æ‰¾åˆ°ç›®æ ‡å¯†ç ï¼Œé‚£å°±æ˜¯æ‰¾ä¸åˆ°äº†
        return -1;
    }

    // å°† s[j] å‘ä¸Šæ‹¨åŠ¨ä¸€æ¬¡
    String plusOne(String s, int j) {
        char[] ch = s.toCharArray();
        if (ch[j] == '9')
            ch[j] = '0';
        else
            ch[j] += 1;
        return new String(ch);
    }

    // å°† s[i] å‘ä¸‹æ‹¨åŠ¨ä¸€æ¬¡
    String minusOne(String s, int j) {
        char[] ch = s.toCharArray();
        if (ch[j] == '0')
            ch[j] = '9';
        else
            ch[j] -= 1;
        return new String(ch);
    }
}
// è¯¦ç»†è§£æå‚è§ï¼š
// https://labuladong.github.io/article/?qno=752

```

